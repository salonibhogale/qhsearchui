{"ast":null,"code":"var _ = require('lodash');\n\nvar extractHostPartsRE1x = /\\[(?:(.*)\\/)?(.+?):(\\d+)\\]/;\n\nfunction makeNodeParser(hostProp) {\n  return function (nodes) {\n    return _.transform(nodes, function (hosts, node, id) {\n      var address = _.get(node, hostProp);\n\n      if (!address) return;\n      var host = {\n        host: undefined,\n        port: undefined,\n        _meta: {\n          id: id,\n          name: node.name,\n          version: node.version\n        }\n      };\n      var malformedError = new Error('Malformed ' + hostProp + '.' + ' Got ' + JSON.stringify(address) + ' and expected it to match \"{hostname?}/{ip}:{port}\".');\n      var matches1x = extractHostPartsRE1x.exec(address);\n\n      if (matches1x) {\n        host.host = matches1x[1] || matches1x[2];\n        host.port = parseInt(matches1x[3], 10);\n        hosts.push(host);\n        return;\n      }\n\n      if (address.indexOf('/') > -1) {\n        var withHostParts = address.split('/');\n        if (withHostParts.length !== 2) throw malformedError;\n        host.host = withHostParts.shift();\n        address = withHostParts.shift();\n      }\n\n      if (address.indexOf(':') < 0) {\n        throw malformedError;\n      }\n\n      var addressParts = address.split(':');\n\n      if (addressParts.length !== 2) {\n        throw malformedError;\n      }\n\n      host.host = host.host || addressParts[0];\n      host.port = parseInt(addressParts[1], 10);\n      hosts.push(host);\n    }, []);\n  };\n}\n\nmodule.exports = makeNodeParser('http.publish_address');","map":{"version":3,"sources":["/Users/mohitkumar/github/qhsearch/new_qhsearch/node_modules/elasticsearch/src/lib/nodes_to_host.js"],"names":["_","require","extractHostPartsRE1x","makeNodeParser","hostProp","nodes","transform","hosts","node","id","address","get","host","undefined","port","_meta","name","version","malformedError","Error","JSON","stringify","matches1x","exec","parseInt","push","indexOf","withHostParts","split","length","shift","addressParts","module","exports"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AAEA,IAAIC,oBAAoB,GAAG,4BAA3B;;AAEA,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AAChC,SAAO,UAASC,KAAT,EAAgB;AACrB,WAAOL,CAAC,CAACM,SAAF,CACLD,KADK,EAEL,UAASE,KAAT,EAAgBC,IAAhB,EAAsBC,EAAtB,EAA0B;AACxB,UAAIC,OAAO,GAAGV,CAAC,CAACW,GAAF,CAAMH,IAAN,EAAYJ,QAAZ,CAAd;;AACA,UAAI,CAACM,OAAL,EAAc;AAEd,UAAIE,IAAI,GAAG;AACTA,QAAAA,IAAI,EAAEC,SADG;AAETC,QAAAA,IAAI,EAAED,SAFG;AAGTE,QAAAA,KAAK,EAAE;AACLN,UAAAA,EAAE,EAAEA,EADC;AAELO,UAAAA,IAAI,EAAER,IAAI,CAACQ,IAFN;AAGLC,UAAAA,OAAO,EAAET,IAAI,CAACS;AAHT;AAHE,OAAX;AAUA,UAAIC,cAAc,GAAG,IAAIC,KAAJ,CACnB,eACEf,QADF,GAEE,GAFF,GAGE,OAHF,GAIEgB,IAAI,CAACC,SAAL,CAAeX,OAAf,CAJF,GAKE,sDANiB,CAArB;AASA,UAAIY,SAAS,GAAGpB,oBAAoB,CAACqB,IAArB,CAA0Bb,OAA1B,CAAhB;;AACA,UAAIY,SAAJ,EAAe;AACbV,QAAAA,IAAI,CAACA,IAAL,GAAYU,SAAS,CAAC,CAAD,CAAT,IAAgBA,SAAS,CAAC,CAAD,CAArC;AACAV,QAAAA,IAAI,CAACE,IAAL,GAAYU,QAAQ,CAACF,SAAS,CAAC,CAAD,CAAV,EAAe,EAAf,CAApB;AACAf,QAAAA,KAAK,CAACkB,IAAN,CAAWb,IAAX;AACA;AACD;;AAED,UAAIF,OAAO,CAACgB,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAA5B,EAA+B;AAC7B,YAAIC,aAAa,GAAGjB,OAAO,CAACkB,KAAR,CAAc,GAAd,CAApB;AACA,YAAID,aAAa,CAACE,MAAd,KAAyB,CAA7B,EAAgC,MAAMX,cAAN;AAEhCN,QAAAA,IAAI,CAACA,IAAL,GAAYe,aAAa,CAACG,KAAd,EAAZ;AACApB,QAAAA,OAAO,GAAGiB,aAAa,CAACG,KAAd,EAAV;AACD;;AAED,UAAIpB,OAAO,CAACgB,OAAR,CAAgB,GAAhB,IAAuB,CAA3B,EAA8B;AAC5B,cAAMR,cAAN;AACD;;AAED,UAAIa,YAAY,GAAGrB,OAAO,CAACkB,KAAR,CAAc,GAAd,CAAnB;;AACA,UAAIG,YAAY,CAACF,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,cAAMX,cAAN;AACD;;AAEDN,MAAAA,IAAI,CAACA,IAAL,GAAYA,IAAI,CAACA,IAAL,IAAamB,YAAY,CAAC,CAAD,CAArC;AACAnB,MAAAA,IAAI,CAACE,IAAL,GAAYU,QAAQ,CAACO,YAAY,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAApB;AACAxB,MAAAA,KAAK,CAACkB,IAAN,CAAWb,IAAX;AACD,KArDI,EAsDL,EAtDK,CAAP;AAwDD,GAzDD;AA0DD;;AAEDoB,MAAM,CAACC,OAAP,GAAiB9B,cAAc,CAAC,sBAAD,CAA/B","sourcesContent":["var _ = require('lodash');\n\nvar extractHostPartsRE1x = /\\[(?:(.*)\\/)?(.+?):(\\d+)\\]/;\n\nfunction makeNodeParser(hostProp) {\n  return function(nodes) {\n    return _.transform(\n      nodes,\n      function(hosts, node, id) {\n        var address = _.get(node, hostProp);\n        if (!address) return;\n\n        var host = {\n          host: undefined,\n          port: undefined,\n          _meta: {\n            id: id,\n            name: node.name,\n            version: node.version,\n          },\n        };\n\n        var malformedError = new Error(\n          'Malformed ' +\n            hostProp +\n            '.' +\n            ' Got ' +\n            JSON.stringify(address) +\n            ' and expected it to match \"{hostname?}/{ip}:{port}\".'\n        );\n\n        var matches1x = extractHostPartsRE1x.exec(address);\n        if (matches1x) {\n          host.host = matches1x[1] || matches1x[2];\n          host.port = parseInt(matches1x[3], 10);\n          hosts.push(host);\n          return;\n        }\n\n        if (address.indexOf('/') > -1) {\n          var withHostParts = address.split('/');\n          if (withHostParts.length !== 2) throw malformedError;\n\n          host.host = withHostParts.shift();\n          address = withHostParts.shift();\n        }\n\n        if (address.indexOf(':') < 0) {\n          throw malformedError;\n        }\n\n        var addressParts = address.split(':');\n        if (addressParts.length !== 2) {\n          throw malformedError;\n        }\n\n        host.host = host.host || addressParts[0];\n        host.port = parseInt(addressParts[1], 10);\n        hosts.push(host);\n      },\n      []\n    );\n  };\n}\n\nmodule.exports = makeNodeParser('http.publish_address');\n"]},"metadata":{},"sourceType":"script"}