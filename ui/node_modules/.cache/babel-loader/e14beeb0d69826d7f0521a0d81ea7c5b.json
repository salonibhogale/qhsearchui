{"ast":null,"code":"var _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar url = require('url');\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * Log bridge, which is an [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * that sends events to one or more outputs/loggers. Setup these loggers by\n * specifying their config as the first argument, or by passing it to addOutput().\n *\n * @class Log\n * @uses Loggers.Stdio\n * @constructor\n * @param {object} config\n * @param {string|Object|ArrayOfStrings|ArrayOfObjects} config.log - Either the level\n *  to setup a single logger, a full config object for a logger, or an array of\n *  config objects to use for creating log outputs.\n * @param {string|array} config.log.level|config.log.levels - One or more keys in Log.levels (error, warning, etc.)\n * @param {string} config.log.type - The name of the logger to use for this output\n */\n\n\nfunction Log(config) {\n  config = config || {};\n  if (!config.log) return;\n  var i;\n  var outputs;\n\n  if (utils.isArrayOfStrings(config.log)) {\n    outputs = [{\n      levels: config.log\n    }];\n  } else {\n    outputs = utils.createArray(config.log, function (val) {\n      if (_.isPlainObject(val)) {\n        return val;\n      }\n\n      if (typeof val === 'string') {\n        return {\n          level: val\n        };\n      }\n    });\n  }\n\n  if (!outputs) {\n    throw new TypeError('Invalid logging output config. Expected either a log level, array of log levels, ' + 'a logger config object, or an array of logger config objects.');\n  }\n\n  for (i = 0; i < outputs.length; i++) {\n    this.addOutput(outputs[i]);\n  }\n}\n\nutils.inherits(Log, EventEmitter);\nLog.loggers = require('./loggers');\n\nLog.prototype.close = function () {\n  this.emit('closing');\n\n  if (this.listenerCount()) {\n    console.error('Something is still listening for log events, but the logger is closing.'); // eslint-disable-line no-console\n\n    this.clearAllListeners();\n  }\n};\n\nif (EventEmitter.prototype.listenerCount) {\n  // If the event emitter implements it's own listenerCount method\n  // we don't need to (newer nodes do this).\n  Log.prototype.listenerCount = EventEmitter.prototype.listenerCount;\n} else if (EventEmitter.listenerCount) {\n  // some versions of node expose EventEmitter::listenerCount\n  // which is more efficient the getting all listeners of a\n  // specific type\n  Log.prototype.listenerCount = function (event) {\n    return EventEmitter.listenerCount(this, event);\n  };\n} else {\n  // all other versions of node expose a #listeners() method, which returns\n  // and array we have to count\n  Log.prototype.listenerCount = function (event) {\n    return this.listeners(event).length;\n  };\n}\n/**\n * Levels observed by the loggers, ordered by rank\n *\n * @property levels\n * @type Array\n * @static\n */\n\n\nLog.levels = [\n/**\n * Event fired for error level log entries\n * @event error\n * @param {Error} error - The error object to log\n */\n'error',\n/**\n * Event fired for \"warning\" level log entries, which usually represent things\n * like correctly formatted error responses from ES (400, ...) and recoverable\n * errors (one node unresponsive)\n *\n * @event warning\n * @param {String} message - A message to be logged\n */\n'warning',\n/**\n * Event fired for \"info\" level log entries, which usually describe what a\n * client is doing (sniffing etc)\n *\n * @event info\n * @param {String} message - A message to be logged\n */\n'info',\n/**\n * Event fired for \"debug\" level log entries, which will describe requests sent,\n * including their url (no data, response codes, or exec times)\n *\n * @event debug\n * @param {String} message - A message to be logged\n */\n'debug',\n/**\n * Event fired for \"trace\" level log entries, which provide detailed information\n * about each request made from a client, including reponse codes, execution times,\n * and a full curl command that can be copied and pasted into a terminal\n *\n * @event trace\n * @param {String} method method, , body, responseStatus, responseBody\n * @param {String} url - The url the request was made to\n * @param {String} body - The body of the request\n * @param {Integer} responseStatus - The status code returned from the response\n * @param {String} responseBody - The body of the response\n */\n'trace'];\n/**\n * Converts a log config value (string or array) to an array of level names which\n * it represents\n *\n * @method parseLevels\n * @static\n * @private\n * @param  {String|ArrayOfStrings} input - Cound be a string to specify the max\n *   level, or an array of exact levels\n * @return {Array} -\n */\n\nLog.parseLevels = function (input) {\n  switch (typeof input) {\n    case 'string':\n      var i = _.indexOf(Log.levels, input);\n\n      if (i >= 0) {\n        return Log.levels.slice(0, i + 1);\n      }\n\n    /* fall through */\n\n    case 'object':\n      if (_.isArray(input)) {\n        var valid = _.intersection(input, Log.levels);\n\n        if (valid.length === input.length) {\n          return valid;\n        }\n      }\n\n    /* fall through */\n\n    default:\n      throw new TypeError('invalid logging level ' + input + '. Expected zero or more of these options: ' + Log.levels.join(', '));\n  }\n};\n/**\n * Combine the array-like param into a simple string\n *\n * @method join\n * @static\n * @private\n * @param  {*} arrayish - An array like object that can be itterated by _.each\n * @return {String} - The final string.\n */\n\n\nLog.join = function (arrayish) {\n  return _.map(arrayish, function (item) {\n    if (_.isPlainObject(item)) {\n      return JSON.stringify(item, null, 2) + '\\n';\n    } else {\n      return item.toString();\n    }\n  }).join(' ');\n};\n/**\n * Create a new logger, based on the config.\n *\n * @method addOutput\n * @param {object} config - An object with config options for the logger.\n * @param {String} [config.type=stdio] - The name of an output/logger. Options\n *   can be found in the `src/loggers` directory.\n * @param {String|ArrayOfStrings} [config.level|config.levels=warning] - The levels to output\n *   to this logger, when an array is specified no levels other than the ones\n *   specified will be listened to. When a string is specified, that and all lower\n *   levels will be logged.\n * @return {Logger}\n */\n\n\nLog.prototype.addOutput = function (config) {\n  config = config || {}; // force \"levels\" key\n\n  config.levels = Log.parseLevels(config.levels || config.level || 'warning');\n  delete config.level;\n  var Logger = utils.funcEnum(config, 'type', Log.loggers, process.browser ? 'console' : 'stdio');\n  return new Logger(this, config);\n};\n/**\n * Log an error\n *\n * @method error\n * @param  {Error|String} error  The Error to log\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.error = function (e) {\n  if (this.listenerCount('error')) {\n    return this.emit('error', e instanceof Error ? e : new Error(e));\n  }\n};\n/**\n * Log a warning message\n *\n * @method warning\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.warning = function ()\n/* ...msg */\n{\n  if (this.listenerCount('warning')) {\n    return this.emit('warning', Log.join(arguments));\n  }\n};\n/**\n * Log useful info about what's going on\n *\n * @method info\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.info = function ()\n/* ...msg */\n{\n  if (this.listenerCount('info')) {\n    return this.emit('info', Log.join(arguments));\n  }\n};\n/**\n * Log a debug level message\n *\n * @method debug\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.debug = function ()\n/* ...msg */\n{\n  if (this.listenerCount('debug')) {\n    return this.emit('debug', Log.join(arguments));\n  }\n};\n/**\n * Log a trace level message\n *\n * @method trace\n * @param {String} method - HTTP request method\n * @param {String|Object} requestUrl - URL requested. If the value is an object,\n *   it is expected to be the return value of Node's url.parse()\n * @param {String} body - The request's body\n * @param {String} responseBody - body returned from ES\n * @param {String} responseStatus - HTTP status code\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.trace = function (method, requestUrl, body, responseBody, responseStatus) {\n  if (this.listenerCount('trace')) {\n    return this.emit('trace', Log.normalizeTraceArgs(method, requestUrl, body, responseBody, responseStatus));\n  }\n};\n\nLog.normalizeTraceArgs = function (method, requestUrl, body, responseBody, responseStatus) {\n  if (typeof requestUrl === 'string') {\n    requestUrl = url.parse(requestUrl, true, true);\n  } else {\n    requestUrl = _.clone(requestUrl);\n\n    if (requestUrl.path) {\n      requestUrl.query = url.parse(requestUrl.path, true, false).query;\n    }\n\n    if (!requestUrl.pathname && requestUrl.path) {\n      requestUrl.pathname = requestUrl.path.split('?').shift();\n    }\n  }\n\n  delete requestUrl.auth;\n  return {\n    method: method,\n    url: url.format(requestUrl),\n    body: body,\n    status: responseStatus,\n    response: responseBody\n  };\n};\n\nmodule.exports = Log;","map":{"version":3,"sources":["/Users/mohitkumar/github/qhsearch/new_qhsearch/ui/node_modules/elasticsearch/src/lib/log.js"],"names":["_","require","utils","url","EventEmitter","Log","config","log","i","outputs","isArrayOfStrings","levels","createArray","val","isPlainObject","level","TypeError","length","addOutput","inherits","loggers","prototype","close","emit","listenerCount","console","error","clearAllListeners","event","listeners","parseLevels","input","indexOf","slice","isArray","valid","intersection","join","arrayish","map","item","JSON","stringify","toString","Logger","funcEnum","process","browser","e","Error","warning","arguments","info","debug","trace","method","requestUrl","body","responseBody","responseStatus","normalizeTraceArgs","parse","clone","path","query","pathname","split","shift","auth","format","status","response","module","exports"],"mappings":"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","sourcesContent":["var _ = require('lodash');\nvar utils = require('./utils');\nvar url = require('url');\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Log bridge, which is an [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * that sends events to one or more outputs/loggers. Setup these loggers by\n * specifying their config as the first argument, or by passing it to addOutput().\n *\n * @class Log\n * @uses Loggers.Stdio\n * @constructor\n * @param {object} config\n * @param {string|Object|ArrayOfStrings|ArrayOfObjects} config.log - Either the level\n *  to setup a single logger, a full config object for a logger, or an array of\n *  config objects to use for creating log outputs.\n * @param {string|array} config.log.level|config.log.levels - One or more keys in Log.levels (error, warning, etc.)\n * @param {string} config.log.type - The name of the logger to use for this output\n */\nfunction Log(config) {\n  config = config || {};\n  if (!config.log) return;\n\n  var i;\n  var outputs;\n\n  if (utils.isArrayOfStrings(config.log)) {\n    outputs = [\n      {\n        levels: config.log,\n      },\n    ];\n  } else {\n    outputs = utils.createArray(config.log, function(val) {\n      if (_.isPlainObject(val)) {\n        return val;\n      }\n      if (typeof val === 'string') {\n        return {\n          level: val,\n        };\n      }\n    });\n  }\n\n  if (!outputs) {\n    throw new TypeError(\n      'Invalid logging output config. Expected either a log level, array of log levels, ' +\n        'a logger config object, or an array of logger config objects.'\n    );\n  }\n\n  for (i = 0; i < outputs.length; i++) {\n    this.addOutput(outputs[i]);\n  }\n}\nutils.inherits(Log, EventEmitter);\n\nLog.loggers = require('./loggers');\n\nLog.prototype.close = function() {\n  this.emit('closing');\n  if (this.listenerCount()) {\n    console.error(\n      'Something is still listening for log events, but the logger is closing.'\n    ); // eslint-disable-line no-console\n    this.clearAllListeners();\n  }\n};\n\nif (EventEmitter.prototype.listenerCount) {\n  // If the event emitter implements it's own listenerCount method\n  // we don't need to (newer nodes do this).\n  Log.prototype.listenerCount = EventEmitter.prototype.listenerCount;\n} else if (EventEmitter.listenerCount) {\n  // some versions of node expose EventEmitter::listenerCount\n  // which is more efficient the getting all listeners of a\n  // specific type\n  Log.prototype.listenerCount = function(event) {\n    return EventEmitter.listenerCount(this, event);\n  };\n} else {\n  // all other versions of node expose a #listeners() method, which returns\n  // and array we have to count\n  Log.prototype.listenerCount = function(event) {\n    return this.listeners(event).length;\n  };\n}\n\n/**\n * Levels observed by the loggers, ordered by rank\n *\n * @property levels\n * @type Array\n * @static\n */\nLog.levels = [\n  /**\n   * Event fired for error level log entries\n   * @event error\n   * @param {Error} error - The error object to log\n   */\n  'error',\n  /**\n   * Event fired for \"warning\" level log entries, which usually represent things\n   * like correctly formatted error responses from ES (400, ...) and recoverable\n   * errors (one node unresponsive)\n   *\n   * @event warning\n   * @param {String} message - A message to be logged\n   */\n  'warning',\n  /**\n   * Event fired for \"info\" level log entries, which usually describe what a\n   * client is doing (sniffing etc)\n   *\n   * @event info\n   * @param {String} message - A message to be logged\n   */\n  'info',\n  /**\n   * Event fired for \"debug\" level log entries, which will describe requests sent,\n   * including their url (no data, response codes, or exec times)\n   *\n   * @event debug\n   * @param {String} message - A message to be logged\n   */\n  'debug',\n  /**\n   * Event fired for \"trace\" level log entries, which provide detailed information\n   * about each request made from a client, including reponse codes, execution times,\n   * and a full curl command that can be copied and pasted into a terminal\n   *\n   * @event trace\n   * @param {String} method method, , body, responseStatus, responseBody\n   * @param {String} url - The url the request was made to\n   * @param {String} body - The body of the request\n   * @param {Integer} responseStatus - The status code returned from the response\n   * @param {String} responseBody - The body of the response\n   */\n  'trace',\n];\n\n/**\n * Converts a log config value (string or array) to an array of level names which\n * it represents\n *\n * @method parseLevels\n * @static\n * @private\n * @param  {String|ArrayOfStrings} input - Cound be a string to specify the max\n *   level, or an array of exact levels\n * @return {Array} -\n */\nLog.parseLevels = function(input) {\n  switch (typeof input) {\n    case 'string':\n      var i = _.indexOf(Log.levels, input);\n      if (i >= 0) {\n        return Log.levels.slice(0, i + 1);\n      }\n    /* fall through */\n    case 'object':\n      if (_.isArray(input)) {\n        var valid = _.intersection(input, Log.levels);\n        if (valid.length === input.length) {\n          return valid;\n        }\n      }\n    /* fall through */\n    default:\n      throw new TypeError(\n        'invalid logging level ' +\n          input +\n          '. Expected zero or more of these options: ' +\n          Log.levels.join(', ')\n      );\n  }\n};\n\n/**\n * Combine the array-like param into a simple string\n *\n * @method join\n * @static\n * @private\n * @param  {*} arrayish - An array like object that can be itterated by _.each\n * @return {String} - The final string.\n */\nLog.join = function(arrayish) {\n  return _.map(arrayish, function(item) {\n    if (_.isPlainObject(item)) {\n      return JSON.stringify(item, null, 2) + '\\n';\n    } else {\n      return item.toString();\n    }\n  }).join(' ');\n};\n\n/**\n * Create a new logger, based on the config.\n *\n * @method addOutput\n * @param {object} config - An object with config options for the logger.\n * @param {String} [config.type=stdio] - The name of an output/logger. Options\n *   can be found in the `src/loggers` directory.\n * @param {String|ArrayOfStrings} [config.level|config.levels=warning] - The levels to output\n *   to this logger, when an array is specified no levels other than the ones\n *   specified will be listened to. When a string is specified, that and all lower\n *   levels will be logged.\n * @return {Logger}\n */\nLog.prototype.addOutput = function(config) {\n  config = config || {};\n\n  // force \"levels\" key\n  config.levels = Log.parseLevels(config.levels || config.level || 'warning');\n  delete config.level;\n\n  var Logger = utils.funcEnum(\n    config,\n    'type',\n    Log.loggers,\n    process.browser ? 'console' : 'stdio'\n  );\n  return new Logger(this, config);\n};\n\n/**\n * Log an error\n *\n * @method error\n * @param  {Error|String} error  The Error to log\n * @return {Boolean} - True if any outputs accepted the message\n */\nLog.prototype.error = function(e) {\n  if (this.listenerCount('error')) {\n    return this.emit('error', e instanceof Error ? e : new Error(e));\n  }\n};\n\n/**\n * Log a warning message\n *\n * @method warning\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\nLog.prototype.warning = function(/* ...msg */) {\n  if (this.listenerCount('warning')) {\n    return this.emit('warning', Log.join(arguments));\n  }\n};\n\n/**\n * Log useful info about what's going on\n *\n * @method info\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\nLog.prototype.info = function(/* ...msg */) {\n  if (this.listenerCount('info')) {\n    return this.emit('info', Log.join(arguments));\n  }\n};\n\n/**\n * Log a debug level message\n *\n * @method debug\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\nLog.prototype.debug = function(/* ...msg */) {\n  if (this.listenerCount('debug')) {\n    return this.emit('debug', Log.join(arguments));\n  }\n};\n\n/**\n * Log a trace level message\n *\n * @method trace\n * @param {String} method - HTTP request method\n * @param {String|Object} requestUrl - URL requested. If the value is an object,\n *   it is expected to be the return value of Node's url.parse()\n * @param {String} body - The request's body\n * @param {String} responseBody - body returned from ES\n * @param {String} responseStatus - HTTP status code\n * @return {Boolean} - True if any outputs accepted the message\n */\nLog.prototype.trace = function(\n  method,\n  requestUrl,\n  body,\n  responseBody,\n  responseStatus\n) {\n  if (this.listenerCount('trace')) {\n    return this.emit(\n      'trace',\n      Log.normalizeTraceArgs(\n        method,\n        requestUrl,\n        body,\n        responseBody,\n        responseStatus\n      )\n    );\n  }\n};\n\nLog.normalizeTraceArgs = function(\n  method,\n  requestUrl,\n  body,\n  responseBody,\n  responseStatus\n) {\n  if (typeof requestUrl === 'string') {\n    requestUrl = url.parse(requestUrl, true, true);\n  } else {\n    requestUrl = _.clone(requestUrl);\n    if (requestUrl.path) {\n      requestUrl.query = url.parse(requestUrl.path, true, false).query;\n    }\n    if (!requestUrl.pathname && requestUrl.path) {\n      requestUrl.pathname = requestUrl.path.split('?').shift();\n    }\n  }\n\n  delete requestUrl.auth;\n\n  return {\n    method: method,\n    url: url.format(requestUrl),\n    body: body,\n    status: responseStatus,\n    response: responseBody,\n  };\n};\n\nmodule.exports = Log;\n"]},"metadata":{},"sourceType":"script"}