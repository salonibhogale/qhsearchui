{"ast":null,"code":"var _ = require('lodash');\n\nvar nodeUtils = require('util');\n/**\n * Custom utils library\n *\n * @class utils\n * @static\n */\n\n\nvar utils = {};\nutils.inherits = nodeUtils.inherits;\n/**\n * Test if a value is an array and its contents are string type\n *\n * @method isArrayOfStrings\n * @param  {Array} arr - An array to check\n * @return {Boolean}\n */\n\nutils.isArrayOfStrings = function (arr) {\n  // quick shallow check of arrays\n  return _.isArray(arr) && _.every(arr.slice(0, 10), _.isString);\n};\n/**\n * Capitalize the first letter of a word\n *\n * @method  ucfirst\n * @param  {string} word - The word to transform\n * @return {string}\n */\n\n\nutils.ucfirst = function (word) {\n  return word[0].toUpperCase() + word.substring(1).toLowerCase();\n};\n/**\n * Base algo for studlyCase and camelCase\n * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized\n * @return {Function}\n */\n\n\nfunction adjustWordCase(firstWordCap, otherWordsCap, sep) {\n  return function (string) {\n    var i = 0;\n    var words = [];\n    var word = '';\n    var code, c, upper, lower;\n\n    for (; i < string.length; i++) {\n      code = string.charCodeAt(i);\n      c = string.charAt(i);\n      lower = code >= 97 && code <= 122 || code >= 48 && code <= 57;\n      upper = code >= 65 && code <= 90;\n\n      if (upper || !lower) {\n        // new word\n        if (word.length) {\n          words.push(word);\n        }\n\n        word = '';\n      }\n\n      if (upper || lower) {\n        if (lower && word.length) {\n          word += c;\n        } else {\n          if (!words.length && firstWordCap || words.length && otherWordsCap) {\n            word = c.toUpperCase();\n          } else {\n            word = c.toLowerCase();\n          }\n        }\n      }\n    }\n\n    if (word.length) {\n      words.push(word);\n    } // add the leading underscore back to strings the had it originally\n\n\n    if (words.length && string.charAt(0) === '_') {\n      words[0] = '_' + words[0];\n    }\n\n    return words.join(sep);\n  };\n}\n/**\n * Transform a string into StudlyCase\n *\n * @method studlyCase\n * @param  {String} string\n * @return {String}\n */\n\n\nutils.studlyCase = adjustWordCase(true, true, '');\n/**\n * Transform a string into camelCase\n *\n * @method camelCase\n * @param  {String} string\n * @return {String}\n */\n\nutils.camelCase = adjustWordCase(false, true, '');\n/**\n * Transform a string into snakeCase\n *\n * @method snakeCase\n * @param  {String} string\n * @return {String}\n */\n\nutils.snakeCase = adjustWordCase(false, false, '_');\n/**\n * Upper-case the string, return an empty string if any is not a string\n *\n * @param any {*} - Something or nothing\n * @returns {string}\n */\n\nutils.toUpperString = function (any) {\n  if (any) {\n    if (typeof any !== 'string') {\n      any = any.toString();\n    }\n  } else {\n    any = '';\n  }\n\n  return any.toUpperCase();\n};\n/**\n * Test if a value is \"numeric\" meaning that it can be transformed into something besides NaN\n *\n * @method isNumeric\n * @param  {*} val\n * @return {Boolean}\n */\n\n\nutils.isNumeric = function (val) {\n  return typeof val !== 'object' && val - parseFloat(val) >= 0;\n}; // regexp to test for intervals\n\n\nvar intervalRE = /^(\\d+(?:\\.\\d+)?)(M|w|d|h|m|s|y|ms)$/;\n/**\n * Test if a string represents an interval (eg. 1m, 2Y)\n *\n * @method isInterval\n * @param {String} val\n * @return {Boolean}\n */\n\nutils.isInterval = function (val) {\n  return !!(val.match && val.match(intervalRE));\n};\n/**\n * Repeat a string n times\n *\n * @todo TestPerformance\n * @method repeat\n * @param {String} what - The string to repeat\n * @param {Number} times - Times the string should be repeated\n * @return {String}\n */\n\n\nutils.repeat = function (what, times) {\n  return new Array(times + 1).join(what);\n};\n/**\n * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array\n *\n * @param func {Function} - The function to execute\n * @param context {*} - The context the function will be executed with\n * @param args {Arguments} - The arguments to send to func\n * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func\n * @returns {*} - the return value of func\n */\n\n\nutils.applyArgs = function (func, context, args, sliceIndex) {\n  sliceIndex = sliceIndex || 0;\n\n  switch (args.length - sliceIndex) {\n    case 0:\n      return func.call(context);\n\n    case 1:\n      return func.call(context, args[0 + sliceIndex]);\n\n    case 2:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);\n\n    case 3:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);\n\n    case 4:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);\n\n    case 5:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);\n\n    default:\n      return func.apply(context, Array.prototype.slice.call(args, sliceIndex));\n  }\n};\n/**\n * Schedule a function to be called on the next tick, and supply it with these arguments\n * when it is called.\n * @return {[type]} [description]\n */\n\n\nutils.nextTick = function (cb) {\n  // bind the function and schedule it\n  process.nextTick(_.bindKey(utils, 'applyArgs', cb, null, arguments, 1));\n};\n/**\n * Marks a method as a handler. Currently this just makes a property on the method\n * flagging it to be bound to the object at object creation when \"makeBoundMethods\" is called\n *\n * ```\n * ClassName.prototype.methodName = utils.handler(function () {\n *   // this will always be bound when called via classInstance.bound.methodName\n *   this === classInstance\n * });\n * ```\n *\n * @param  {Function} func - The method that is being defined\n * @return {Function}\n */\n\n\nutils.handler = function (func) {\n  func._provideBound = true;\n  return func;\n};\n/**\n * Creates an \"bound\" property on an object, which all or a subset of methods from\n * the object which are bound to the original object.\n *\n * ```\n * var obj = {\n *   onEvent: function () {}\n * };\n *\n * utils.makeBoundMethods(obj);\n *\n * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.\n * ```\n *\n * @param {Object} obj - The object to bind the methods to\n */\n\n\nutils.makeBoundMethods = function (obj) {\n  obj.bound = {};\n\n  for (var prop in obj) {\n    // dearest maintainer, we want to look through the prototype\n    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {\n      obj.bound[prop] = _.bind(obj[prop], obj);\n    }\n  }\n};\n/**\n * Implements the standard \"string or constructor\" check that I was copy/pasting everywhere\n * @param  {String|Function} val - the value that the user passed in\n * @param  {Object} opts - a map of the options\n * @return {Function|undefined} - If a valid option was specified, then the constructor is returned\n */\n\n\nutils.funcEnum = function (config, name, opts, def) {\n  var val = config[name];\n\n  switch (typeof val) {\n    case 'undefined':\n      return opts[def];\n\n    case 'function':\n      return val;\n\n    case 'string':\n      if (opts.hasOwnProperty(val)) {\n        return opts[val];\n      }\n\n    /* falls through */\n\n    default:\n      var err = 'Invalid ' + name + ' \"' + val + '\", expected a function';\n\n      switch (_.size(opts)) {\n        case 0:\n          break;\n\n        case 1:\n          err += ' or ' + _.keys(opts)[0];\n          break;\n\n        default:\n          err += ' or one of ' + _.keys(opts).join(', ');\n          break;\n      }\n\n      throw new TypeError(err);\n  }\n};\n/**\n * Accepts any object and attempts to convert it into an array. If the object passed in is not\n * an array it will be wrapped in one. Then the transform/map function will be called for each element\n * and create a new array that is returned. If the map function fails to return something, the loop is\n * halted and false is returned instead of an array.\n *\n * @param  {*} input - The value to convert\n * @param  {Function} transform - A function called for each element of the resulting array\n * @return {Array|false} - an array on success, or false on failure.\n */\n\n\nutils.createArray = function (input, transform) {\n  transform = typeof transform === 'function' ? transform : _.identity;\n  var output = [];\n  var item;\n  var i;\n\n  if (!_.isArray(input)) {\n    input = [input];\n  }\n\n  for (i = 0; i < input.length; i++) {\n    item = transform(input[i]);\n\n    if (item === void 0) {\n      return false;\n    } else {\n      output.push(item);\n    }\n  }\n\n  return output;\n};\n/**\n * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.\n *\n * ONLY WORKS FOR TEXT STREAMS\n *\n * @param  {WritableStream} stream - an instance of stream.Writable\n * @return {string} - the remaining test to be written to the stream\n */\n\n\nutils.getUnwrittenFromStream = function (stream) {\n  var writeBuffer = utils.getStreamWriteBuffer(stream);\n  if (!writeBuffer) return; // flush the write buffer\n\n  var out = '';\n  if (!writeBuffer.length) return out;\n\n  _.each(writeBuffer, function (writeReq) {\n    if (writeReq.chunk) {\n      // 0.9.12+ uses WriteReq objects with a chunk prop\n      out += '' + writeReq.chunk;\n    } else if (_.isArray(writeReq) && (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))) {\n      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].\n      out += '' + writeReq[0];\n    } else {\n      return false;\n    }\n  });\n\n  return out;\n};\n\nutils.getStreamWriteBuffer = function (stream) {\n  if (!stream || !stream._writableState) return;\n  var writeState = stream._writableState;\n\n  if (writeState.getBuffer) {\n    return writeState.getBuffer();\n  } else if (writeState.buffer) {\n    return writeState.buffer;\n  }\n};\n\nutils.clearWriteStreamBuffer = function (stream) {\n  var buffer = utils.getStreamWriteBuffer(stream);\n  return buffer && buffer.splice(0);\n};\n/**\n * return the current time in milliseconds since epoch\n */\n\n\nutils.now = function () {\n  return typeof Date.now === 'function' ? Date.now() : new Date().getTime();\n};\n\nmodule.exports = utils;","map":{"version":3,"sources":["/Users/mohitkumar/github/qhsearch/new_qhsearch/node_modules/elasticsearch/src/lib/utils.js"],"names":["_","require","nodeUtils","utils","inherits","isArrayOfStrings","arr","isArray","every","slice","isString","ucfirst","word","toUpperCase","substring","toLowerCase","adjustWordCase","firstWordCap","otherWordsCap","sep","string","i","words","code","c","upper","lower","length","charCodeAt","charAt","push","join","studlyCase","camelCase","snakeCase","toUpperString","any","toString","isNumeric","val","parseFloat","intervalRE","isInterval","match","repeat","what","times","Array","applyArgs","func","context","args","sliceIndex","call","apply","prototype","nextTick","cb","process","bindKey","arguments","handler","_provideBound","makeBoundMethods","obj","bound","prop","bind","funcEnum","config","name","opts","def","hasOwnProperty","err","size","keys","TypeError","createArray","input","transform","identity","output","item","getUnwrittenFromStream","stream","writeBuffer","getStreamWriteBuffer","out","each","writeReq","chunk","Buffer","isBuffer","_writableState","writeState","getBuffer","buffer","clearWriteStreamBuffer","splice","now","Date","getTime","module","exports"],"mappings":"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","sourcesContent":["var _ = require('lodash');\nvar nodeUtils = require('util');\n\n/**\n * Custom utils library\n *\n * @class utils\n * @static\n */\nvar utils = {};\n\nutils.inherits = nodeUtils.inherits;\n\n/**\n * Test if a value is an array and its contents are string type\n *\n * @method isArrayOfStrings\n * @param  {Array} arr - An array to check\n * @return {Boolean}\n */\nutils.isArrayOfStrings = function(arr) {\n  // quick shallow check of arrays\n  return _.isArray(arr) && _.every(arr.slice(0, 10), _.isString);\n};\n\n/**\n * Capitalize the first letter of a word\n *\n * @method  ucfirst\n * @param  {string} word - The word to transform\n * @return {string}\n */\nutils.ucfirst = function(word) {\n  return word[0].toUpperCase() + word.substring(1).toLowerCase();\n};\n\n/**\n * Base algo for studlyCase and camelCase\n * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized\n * @return {Function}\n */\nfunction adjustWordCase(firstWordCap, otherWordsCap, sep) {\n  return function(string) {\n    var i = 0;\n    var words = [];\n    var word = '';\n    var code, c, upper, lower;\n\n    for (; i < string.length; i++) {\n      code = string.charCodeAt(i);\n      c = string.charAt(i);\n      lower = (code >= 97 && code <= 122) || (code >= 48 && code <= 57);\n      upper = code >= 65 && code <= 90;\n\n      if (upper || !lower) {\n        // new word\n        if (word.length) {\n          words.push(word);\n        }\n        word = '';\n      }\n\n      if (upper || lower) {\n        if (lower && word.length) {\n          word += c;\n        } else {\n          if (\n            (!words.length && firstWordCap) ||\n            (words.length && otherWordsCap)\n          ) {\n            word = c.toUpperCase();\n          } else {\n            word = c.toLowerCase();\n          }\n        }\n      }\n    }\n    if (word.length) {\n      words.push(word);\n    }\n    // add the leading underscore back to strings the had it originally\n    if (words.length && string.charAt(0) === '_') {\n      words[0] = '_' + words[0];\n    }\n    return words.join(sep);\n  };\n}\n\n/**\n * Transform a string into StudlyCase\n *\n * @method studlyCase\n * @param  {String} string\n * @return {String}\n */\nutils.studlyCase = adjustWordCase(true, true, '');\n\n/**\n * Transform a string into camelCase\n *\n * @method camelCase\n * @param  {String} string\n * @return {String}\n */\nutils.camelCase = adjustWordCase(false, true, '');\n\n/**\n * Transform a string into snakeCase\n *\n * @method snakeCase\n * @param  {String} string\n * @return {String}\n */\nutils.snakeCase = adjustWordCase(false, false, '_');\n\n/**\n * Upper-case the string, return an empty string if any is not a string\n *\n * @param any {*} - Something or nothing\n * @returns {string}\n */\nutils.toUpperString = function(any) {\n  if (any) {\n    if (typeof any !== 'string') {\n      any = any.toString();\n    }\n  } else {\n    any = '';\n  }\n  return any.toUpperCase();\n};\n\n/**\n * Test if a value is \"numeric\" meaning that it can be transformed into something besides NaN\n *\n * @method isNumeric\n * @param  {*} val\n * @return {Boolean}\n */\nutils.isNumeric = function(val) {\n  return typeof val !== 'object' && val - parseFloat(val) >= 0;\n};\n\n// regexp to test for intervals\nvar intervalRE = /^(\\d+(?:\\.\\d+)?)(M|w|d|h|m|s|y|ms)$/;\n\n/**\n * Test if a string represents an interval (eg. 1m, 2Y)\n *\n * @method isInterval\n * @param {String} val\n * @return {Boolean}\n */\nutils.isInterval = function(val) {\n  return !!(val.match && val.match(intervalRE));\n};\n\n/**\n * Repeat a string n times\n *\n * @todo TestPerformance\n * @method repeat\n * @param {String} what - The string to repeat\n * @param {Number} times - Times the string should be repeated\n * @return {String}\n */\nutils.repeat = function(what, times) {\n  return new Array(times + 1).join(what);\n};\n\n/**\n * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array\n *\n * @param func {Function} - The function to execute\n * @param context {*} - The context the function will be executed with\n * @param args {Arguments} - The arguments to send to func\n * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func\n * @returns {*} - the return value of func\n */\nutils.applyArgs = function(func, context, args, sliceIndex) {\n  sliceIndex = sliceIndex || 0;\n  switch (args.length - sliceIndex) {\n    case 0:\n      return func.call(context);\n    case 1:\n      return func.call(context, args[0 + sliceIndex]);\n    case 2:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);\n    case 3:\n      return func.call(\n        context,\n        args[0 + sliceIndex],\n        args[1 + sliceIndex],\n        args[2 + sliceIndex]\n      );\n    case 4:\n      return func.call(\n        context,\n        args[0 + sliceIndex],\n        args[1 + sliceIndex],\n        args[2 + sliceIndex],\n        args[3 + sliceIndex]\n      );\n    case 5:\n      return func.call(\n        context,\n        args[0 + sliceIndex],\n        args[1 + sliceIndex],\n        args[2 + sliceIndex],\n        args[3 + sliceIndex],\n        args[4 + sliceIndex]\n      );\n    default:\n      return func.apply(context, Array.prototype.slice.call(args, sliceIndex));\n  }\n};\n\n/**\n * Schedule a function to be called on the next tick, and supply it with these arguments\n * when it is called.\n * @return {[type]} [description]\n */\nutils.nextTick = function(cb) {\n  // bind the function and schedule it\n  process.nextTick(_.bindKey(utils, 'applyArgs', cb, null, arguments, 1));\n};\n\n/**\n * Marks a method as a handler. Currently this just makes a property on the method\n * flagging it to be bound to the object at object creation when \"makeBoundMethods\" is called\n *\n * ```\n * ClassName.prototype.methodName = utils.handler(function () {\n *   // this will always be bound when called via classInstance.bound.methodName\n *   this === classInstance\n * });\n * ```\n *\n * @param  {Function} func - The method that is being defined\n * @return {Function}\n */\nutils.handler = function(func) {\n  func._provideBound = true;\n  return func;\n};\n\n/**\n * Creates an \"bound\" property on an object, which all or a subset of methods from\n * the object which are bound to the original object.\n *\n * ```\n * var obj = {\n *   onEvent: function () {}\n * };\n *\n * utils.makeBoundMethods(obj);\n *\n * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.\n * ```\n *\n * @param {Object} obj - The object to bind the methods to\n */\nutils.makeBoundMethods = function(obj) {\n  obj.bound = {};\n  for (var prop in obj) {\n    // dearest maintainer, we want to look through the prototype\n    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {\n      obj.bound[prop] = _.bind(obj[prop], obj);\n    }\n  }\n};\n\n/**\n * Implements the standard \"string or constructor\" check that I was copy/pasting everywhere\n * @param  {String|Function} val - the value that the user passed in\n * @param  {Object} opts - a map of the options\n * @return {Function|undefined} - If a valid option was specified, then the constructor is returned\n */\nutils.funcEnum = function(config, name, opts, def) {\n  var val = config[name];\n  switch (typeof val) {\n    case 'undefined':\n      return opts[def];\n    case 'function':\n      return val;\n    case 'string':\n      if (opts.hasOwnProperty(val)) {\n        return opts[val];\n      }\n    /* falls through */\n    default:\n      var err = 'Invalid ' + name + ' \"' + val + '\", expected a function';\n      switch (_.size(opts)) {\n        case 0:\n          break;\n        case 1:\n          err += ' or ' + _.keys(opts)[0];\n          break;\n        default:\n          err += ' or one of ' + _.keys(opts).join(', ');\n          break;\n      }\n      throw new TypeError(err);\n  }\n};\n\n/**\n * Accepts any object and attempts to convert it into an array. If the object passed in is not\n * an array it will be wrapped in one. Then the transform/map function will be called for each element\n * and create a new array that is returned. If the map function fails to return something, the loop is\n * halted and false is returned instead of an array.\n *\n * @param  {*} input - The value to convert\n * @param  {Function} transform - A function called for each element of the resulting array\n * @return {Array|false} - an array on success, or false on failure.\n */\nutils.createArray = function(input, transform) {\n  transform = typeof transform === 'function' ? transform : _.identity;\n  var output = [];\n  var item;\n  var i;\n\n  if (!_.isArray(input)) {\n    input = [input];\n  }\n\n  for (i = 0; i < input.length; i++) {\n    item = transform(input[i]);\n    if (item === void 0) {\n      return false;\n    } else {\n      output.push(item);\n    }\n  }\n  return output;\n};\n\n/**\n * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.\n *\n * ONLY WORKS FOR TEXT STREAMS\n *\n * @param  {WritableStream} stream - an instance of stream.Writable\n * @return {string} - the remaining test to be written to the stream\n */\nutils.getUnwrittenFromStream = function(stream) {\n  var writeBuffer = utils.getStreamWriteBuffer(stream);\n  if (!writeBuffer) return;\n\n  // flush the write buffer\n  var out = '';\n  if (!writeBuffer.length) return out;\n\n  _.each(writeBuffer, function(writeReq) {\n    if (writeReq.chunk) {\n      // 0.9.12+ uses WriteReq objects with a chunk prop\n      out += '' + writeReq.chunk;\n    } else if (\n      _.isArray(writeReq) &&\n      (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))\n    ) {\n      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].\n      out += '' + writeReq[0];\n    } else {\n      return false;\n    }\n  });\n  return out;\n};\n\nutils.getStreamWriteBuffer = function(stream) {\n  if (!stream || !stream._writableState) return;\n\n  var writeState = stream._writableState;\n\n  if (writeState.getBuffer) {\n    return writeState.getBuffer();\n  } else if (writeState.buffer) {\n    return writeState.buffer;\n  }\n};\n\nutils.clearWriteStreamBuffer = function(stream) {\n  var buffer = utils.getStreamWriteBuffer(stream);\n  return buffer && buffer.splice(0);\n};\n\n/**\n * return the current time in milliseconds since epoch\n */\nutils.now = function() {\n  return typeof Date.now === 'function' ? Date.now() : new Date().getTime();\n};\n\nmodule.exports = utils;\n"]},"metadata":{},"sourceType":"script"}