{"ast":null,"code":"/**\n * Class that manages making request, called by all of the API methods.\n * @type {[type]}\n */\nmodule.exports = Transport;\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar errors = require('./errors');\n\nvar Host = require('./host');\n\nvar patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');\n\nvar findCommonProtocol = require('./transport/find_common_protocol');\n\nfunction Transport(config) {\n  var self = this;\n  config = self._config = config || {};\n  var LogClass = typeof config.log === 'function' ? config.log : require('./log');\n  config.log = self.log = new LogClass(config); // setup the connection pool\n\n  var ConnectionPool = utils.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');\n  self.connectionPool = new ConnectionPool(config); // setup the serializer\n\n  var Serializer = utils.funcEnum(config, 'serializer', Transport.serializers, 'json');\n  self.serializer = new Serializer(config); // setup the nodesToHostCallback\n\n  self.nodesToHostCallback = utils.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main'); // setup max retries\n\n  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3; // setup endpoint to use for sniffing\n\n  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/http'; // setup requestTimeout default\n\n  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;\n  self.pingTimeout = config.hasOwnProperty('pingTimeout') ? config.pingTimeout : 3000;\n\n  if (config.hasOwnProperty('defer')) {\n    self.defer = config.defer;\n  } // randomizeHosts option\n\n\n  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;\n\n  if (config.host) {\n    config.hosts = config.host;\n  }\n\n  if (config.hosts) {\n    var hostsConfig = utils.createArray(config.hosts, function (val) {\n      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {\n        return val;\n      }\n    });\n\n    if (!hostsConfig) {\n      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' + 'or an array of host config objects.');\n    }\n\n    if (randomizeHosts) {\n      hostsConfig = _.shuffle(hostsConfig);\n    }\n\n    self.setHosts(hostsConfig);\n  }\n\n  if (config.hasOwnProperty('sniffedNodesProtocol')) {\n    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;\n  } else {\n    self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null;\n  }\n\n  if (config.hasOwnProperty('sniffedNodesFilterPath')) {\n    self.sniffedNodesFilterPath = config.sniffedNodesFilterPath;\n  } else {\n    self.sniffedNodesFilterPath = ['nodes.*.http.publish_address', 'nodes.*.name', 'nodes.*.hostname', 'nodes.*.host', 'nodes.*.version'].join(',');\n  }\n\n  if (config.sniffOnStart) {\n    self.sniff();\n  }\n\n  if (config.sniffInterval) {\n    self._timeout(function doSniff() {\n      self.sniff();\n\n      self._timeout(doSniff, config.sniffInterval);\n    }, config.sniffInterval);\n  }\n\n  if (config.sniffOnConnectionFault) {\n    patchSniffOnConnectionFault(self);\n  }\n}\n\nTransport.connectionPools = {\n  main: require('./connection_pool')\n};\nTransport.serializers = require('./serializers');\nTransport.nodesToHostCallbacks = {\n  main: require('./nodes_to_host')\n};\n\nTransport.prototype.defer = function () {\n  if (typeof Promise === 'undefined') {\n    throw new Error('No Promise implementation found. In order for elasticsearch-js to create promises ' + 'either specify the `defer` configuration or include a global Promise shim');\n  }\n\n  var defer = {};\n  defer.promise = new Promise(function (resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n};\n/**\n * Perform a request with the client's transport\n *\n * @method request\n * @todo async body writing\n * @todo abort\n * @todo access to custom headers, modifying of request in general\n * @param {object} params\n * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)\n * @param {Number} params.maxRetries - number of times to re-run request if the\n *   original node chosen can not be connected to.\n * @param {string} [params.path=\"/\"] - URL pathname. Do not include query string.\n * @param {string|object} [params.query] - Query string.\n * @param {String} params.method - The HTTP method for the request\n * @param {String} params.body - The body of the HTTP request\n * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)\n */\n\n\nTransport.prototype.request = function (params, cb) {\n  var self = this;\n  var remainingRetries = this.maxRetries;\n  var requestTimeout = this.requestTimeout;\n  var connection; // set in sendReqWithConnection\n\n  var aborted = false; // several connector will respond with an error when the request is aborted\n\n  var requestAborter; // an abort function, returned by connection#request()\n\n  var requestTimeoutId; // the id of the ^timeout\n\n  var ret; // the object returned to the user, might be a promise\n\n  var defer; // the defer object, will be set when we are using promises.\n\n  var body = params.body;\n  var headers = !params.headers ? {} : _.transform(params.headers, function (headers, val, name) {\n    headers[String(name).toLowerCase()] = val;\n  });\n  self.log.debug('starting request', params); // determine the response based on the presense of a callback\n\n  if (typeof cb === 'function') {\n    // handle callbacks within a domain\n    if (process.domain) {\n      cb = process.domain.bind(cb);\n    }\n\n    ret = {\n      abort: abortRequest\n    };\n  } else {\n    defer = this.defer();\n    ret = defer.promise;\n    ret.abort = abortRequest;\n  }\n\n  if (body && params.method === 'GET') {\n    utils.nextTick(respond, new TypeError('Body can not be sent with method \"GET\"'));\n    return ret;\n  } // serialize the body\n\n\n  if (body) {\n    var serializer = self.serializer;\n    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];\n    body = serializeFn.call(serializer, body);\n\n    if (!headers['content-type']) {\n      headers['content-type'] = serializeFn.contentType;\n    }\n  }\n\n  if (params.hasOwnProperty('maxRetries')) {\n    remainingRetries = params.maxRetries;\n  }\n\n  if (params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  const pingRequest = params.path === '/' && params.method === 'HEAD';\n\n  if (pingRequest) {\n    const requestParam = params.hasOwnProperty('requestTimeout') && params.requestTimeout;\n    requestTimeout = requestParam || this.pingTimeout;\n  }\n\n  params.req = {\n    method: params.method,\n    path: params.path || '/',\n    query: params.query,\n    body: body,\n    headers: headers\n  };\n\n  function sendReqWithConnection(err, _connection) {\n    if (aborted) {\n      return;\n    }\n\n    if (err) {\n      respond(err);\n    } else if (_connection) {\n      connection = _connection;\n      requestAborter = connection.request(params.req, checkRespForFailure);\n    } else {\n      self.log.warning('No living connections');\n      respond(new errors.NoConnections());\n    }\n  }\n\n  function checkRespForFailure(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    requestAborter = void 0;\n\n    if (err instanceof errors.RequestTypeError) {\n      self.log.error('Connection refused to execute the request', err);\n      respond(err, body, status, headers);\n      return;\n    }\n\n    if (err) {\n      connection.setStatus('dead');\n      var errMsg = err.message || '';\n      errMsg = '\\n' + params.req.method + ' ' + connection.host.makeUrl(params.req) + (errMsg.length ? ' => ' : '') + errMsg;\n\n      if (remainingRetries) {\n        remainingRetries--;\n        self.log.error('Request error, retrying' + errMsg);\n        self.connectionPool.select(sendReqWithConnection);\n      } else {\n        self.log.error('Request complete with error' + errMsg);\n        respond(new errors.ConnectionFault(err));\n      }\n    } else {\n      self.log.debug('Request complete');\n      respond(void 0, body, status, headers);\n    }\n  }\n\n  function respond(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    self._timeout(requestTimeoutId);\n\n    var parsedBody;\n    var isJson = !headers || headers['content-type'] && ~headers['content-type'].indexOf('application/json');\n\n    if (!err && body) {\n      if (isJson) {\n        parsedBody = self.serializer.deserialize(body);\n\n        if (parsedBody == null) {\n          err = new errors.Serialization();\n          parsedBody = body;\n        }\n      } else {\n        parsedBody = body;\n      }\n    } // does the response represent an error?\n\n\n    if ((!err || err instanceof errors.Serialization) && (status < 200 || status >= 300) && (!params.ignore || !_.includes(params.ignore, status))) {\n      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);\n\n      errorMetadata.statusCode = status;\n      errorMetadata.response = body;\n\n      if (status === 401 && headers && headers['www-authenticate']) {\n        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];\n      }\n\n      if (errors[status]) {\n        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);\n      } else {\n        err = new errors.Generic('unknown error', errorMetadata);\n      }\n    } // can we cast notfound to false?\n\n\n    if (params.castExists) {\n      if (err && err instanceof errors.NotFound) {\n        parsedBody = false;\n        err = void 0;\n      } else {\n        parsedBody = !err;\n      }\n    } // how do we send the response?\n\n\n    if (typeof cb === 'function') {\n      if (err) {\n        cb(err, parsedBody, status);\n      } else {\n        cb(void 0, parsedBody, status);\n      }\n    } else if (err) {\n      err.body = parsedBody;\n      err.status = status;\n      defer.reject(err);\n    } else {\n      defer.resolve(parsedBody);\n    }\n  }\n\n  function abortRequest() {\n    if (aborted) {\n      return;\n    }\n\n    aborted = true;\n    remainingRetries = 0;\n\n    self._timeout(requestTimeoutId);\n\n    if (typeof requestAborter === 'function') {\n      requestAborter();\n    }\n  }\n\n  if (requestTimeout && requestTimeout !== Infinity) {\n    requestTimeoutId = this._timeout(function () {\n      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));\n      abortRequest();\n    }, requestTimeout);\n  }\n\n  if (connection) {\n    sendReqWithConnection(void 0, connection);\n  } else {\n    self.connectionPool.select(sendReqWithConnection);\n  }\n\n  return ret;\n};\n\nTransport.prototype._timeout = function (cb, delay) {\n  if (this.closed) return;\n  var id;\n  var timers = this._timers || (this._timers = []);\n\n  if (typeof cb !== 'function') {\n    id = cb;\n    cb = void 0;\n  }\n\n  if (cb) {\n    // set the timer\n    id = setTimeout(function () {\n      _.pull(timers, id);\n\n      cb();\n    }, delay);\n    timers.push(id);\n    return id;\n  }\n\n  if (id) {\n    clearTimeout(id);\n\n    var i = this._timers.indexOf(id);\n\n    if (i !== -1) {\n      this._timers.splice(i, 1);\n    }\n  }\n};\n/**\n * Ask an ES node for a list of all the nodes, add/remove nodes from the connection\n * pool as appropriate\n *\n * @param  {Function} cb - Function to call back once complete\n */\n\n\nTransport.prototype.sniff = function (cb) {\n  var self = this;\n  var nodesToHostCallback = this.nodesToHostCallback;\n  var log = this.log;\n  var sniffedNodesProtocol = this.sniffedNodesProtocol;\n  var sniffedNodesFilterPath = this.sniffedNodesFilterPath; // make cb a function if it isn't\n\n  cb = typeof cb === 'function' ? cb : _.noop;\n  this.request({\n    path: this.sniffEndpoint,\n    query: {\n      filter_path: sniffedNodesFilterPath\n    },\n    method: 'GET'\n  }, function (err, resp, status) {\n    if (!err && resp && resp.nodes) {\n      var hostsConfigs;\n\n      try {\n        hostsConfigs = nodesToHostCallback(resp.nodes);\n      } catch (e) {\n        log.error(new Error('Unable to convert node list from ' + self.sniffEndpoint + ' to hosts durring sniff. Encountered error:\\n' + (e.stack || e.message)));\n        return;\n      }\n\n      _.forEach(hostsConfigs, function (hostConfig) {\n        if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;\n      });\n\n      self.setHosts(hostsConfigs);\n    }\n\n    cb(err, resp, status);\n  });\n};\n/**\n * Set the host list that the transport should use.\n *\n * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects\n *                                         that will be used to create Host objects.\n */\n\n\nTransport.prototype.setHosts = function (hostsConfigs) {\n  var globalConfig = this._config;\n  this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {\n    return conf instanceof Host ? conf : new Host(conf, globalConfig);\n  }));\n};\n/**\n * Close the Transport, which closes the logs and connection pool\n * @return {[type]} [description]\n */\n\n\nTransport.prototype.close = function () {\n  this.log.close();\n  this.closed = true;\n\n  _.each(this._timers, clearTimeout);\n\n  this._timers = null;\n  this.connectionPool.close();\n};","map":{"version":3,"sources":["/Users/mohitkumar/github/qhsearch/new_qhsearch/ui/node_modules/elasticsearch/src/lib/transport.js"],"names":["module","exports","Transport","_","require","utils","errors","Host","patchSniffOnConnectionFault","findCommonProtocol","config","self","_config","LogClass","log","ConnectionPool","funcEnum","connectionPools","connectionPool","Serializer","serializers","serializer","nodesToHostCallback","nodesToHostCallbacks","maxRetries","hasOwnProperty","sniffEndpoint","requestTimeout","pingTimeout","defer","randomizeHosts","host","hosts","hostsConfig","createArray","val","isPlainObject","isString","TypeError","shuffle","setHosts","sniffedNodesProtocol","getAllHosts","sniffedNodesFilterPath","join","sniffOnStart","sniff","sniffInterval","_timeout","doSniff","sniffOnConnectionFault","main","prototype","Promise","Error","promise","resolve","reject","request","params","cb","remainingRetries","connection","aborted","requestAborter","requestTimeoutId","ret","body","headers","transform","name","String","toLowerCase","debug","process","domain","bind","abort","abortRequest","method","nextTick","respond","serializeFn","bulkBody","call","contentType","pingRequest","path","requestParam","req","query","sendReqWithConnection","err","_connection","checkRespForFailure","warning","NoConnections","status","RequestTypeError","error","setStatus","errMsg","message","makeUrl","length","select","ConnectionFault","parsedBody","isJson","indexOf","deserialize","Serialization","ignore","includes","errorMetadata","pick","statusCode","response","wwwAuthenticateDirective","Generic","castExists","NotFound","Infinity","RequestTimeout","delay","closed","id","timers","_timers","setTimeout","pull","push","clearTimeout","i","splice","noop","filter_path","resp","nodes","hostsConfigs","e","stack","forEach","hostConfig","protocol","globalConfig","map","conf","close","each"],"mappings":"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","sourcesContent":["/**\n * Class that manages making request, called by all of the API methods.\n * @type {[type]}\n */\nmodule.exports = Transport;\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar errors = require('./errors');\nvar Host = require('./host');\nvar patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');\nvar findCommonProtocol = require('./transport/find_common_protocol');\n\nfunction Transport(config) {\n  var self = this;\n  config = self._config = config || {};\n\n  var LogClass =\n    typeof config.log === 'function' ? config.log : require('./log');\n  config.log = self.log = new LogClass(config);\n\n  // setup the connection pool\n  var ConnectionPool = utils.funcEnum(\n    config,\n    'connectionPool',\n    Transport.connectionPools,\n    'main'\n  );\n  self.connectionPool = new ConnectionPool(config);\n\n  // setup the serializer\n  var Serializer = utils.funcEnum(\n    config,\n    'serializer',\n    Transport.serializers,\n    'json'\n  );\n  self.serializer = new Serializer(config);\n\n  // setup the nodesToHostCallback\n  self.nodesToHostCallback = utils.funcEnum(\n    config,\n    'nodesToHostCallback',\n    Transport.nodesToHostCallbacks,\n    'main'\n  );\n\n  // setup max retries\n  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3;\n\n  // setup endpoint to use for sniffing\n  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint')\n    ? config.sniffEndpoint\n    : '/_nodes/_all/http';\n\n  // setup requestTimeout default\n  self.requestTimeout = config.hasOwnProperty('requestTimeout')\n    ? config.requestTimeout\n    : 30000;\n  self.pingTimeout = config.hasOwnProperty('pingTimeout')\n    ? config.pingTimeout\n    : 3000;\n\n  if (config.hasOwnProperty('defer')) {\n    self.defer = config.defer;\n  }\n\n  // randomizeHosts option\n  var randomizeHosts = config.hasOwnProperty('randomizeHosts')\n    ? !!config.randomizeHosts\n    : true;\n\n  if (config.host) {\n    config.hosts = config.host;\n  }\n\n  if (config.hosts) {\n    var hostsConfig = utils.createArray(config.hosts, function(val) {\n      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {\n        return val;\n      }\n    });\n\n    if (!hostsConfig) {\n      throw new TypeError(\n        'Invalid hosts config. Expected a URL, an array of urls, a host config object, ' +\n          'or an array of host config objects.'\n      );\n    }\n\n    if (randomizeHosts) {\n      hostsConfig = _.shuffle(hostsConfig);\n    }\n\n    self.setHosts(hostsConfig);\n  }\n\n  if (config.hasOwnProperty('sniffedNodesProtocol')) {\n    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;\n  } else {\n    self.sniffedNodesProtocol =\n      findCommonProtocol(self.connectionPool.getAllHosts()) || null;\n  }\n\n  if (config.hasOwnProperty('sniffedNodesFilterPath')) {\n    self.sniffedNodesFilterPath = config.sniffedNodesFilterPath;\n  } else {\n    self.sniffedNodesFilterPath = [\n      'nodes.*.http.publish_address',\n      'nodes.*.name',\n      'nodes.*.hostname',\n      'nodes.*.host',\n      'nodes.*.version',\n    ].join(',');\n  }\n\n  if (config.sniffOnStart) {\n    self.sniff();\n  }\n\n  if (config.sniffInterval) {\n    self._timeout(function doSniff() {\n      self.sniff();\n      self._timeout(doSniff, config.sniffInterval);\n    }, config.sniffInterval);\n  }\n\n  if (config.sniffOnConnectionFault) {\n    patchSniffOnConnectionFault(self);\n  }\n}\n\nTransport.connectionPools = {\n  main: require('./connection_pool'),\n};\n\nTransport.serializers = require('./serializers');\n\nTransport.nodesToHostCallbacks = {\n  main: require('./nodes_to_host'),\n};\n\nTransport.prototype.defer = function() {\n  if (typeof Promise === 'undefined') {\n    throw new Error(\n      'No Promise implementation found. In order for elasticsearch-js to create promises ' +\n        'either specify the `defer` configuration or include a global Promise shim'\n    );\n  }\n\n  var defer = {};\n  defer.promise = new Promise(function(resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n};\n\n/**\n * Perform a request with the client's transport\n *\n * @method request\n * @todo async body writing\n * @todo abort\n * @todo access to custom headers, modifying of request in general\n * @param {object} params\n * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)\n * @param {Number} params.maxRetries - number of times to re-run request if the\n *   original node chosen can not be connected to.\n * @param {string} [params.path=\"/\"] - URL pathname. Do not include query string.\n * @param {string|object} [params.query] - Query string.\n * @param {String} params.method - The HTTP method for the request\n * @param {String} params.body - The body of the HTTP request\n * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)\n */\nTransport.prototype.request = function(params, cb) {\n  var self = this;\n  var remainingRetries = this.maxRetries;\n  var requestTimeout = this.requestTimeout;\n\n  var connection; // set in sendReqWithConnection\n  var aborted = false; // several connector will respond with an error when the request is aborted\n  var requestAborter; // an abort function, returned by connection#request()\n  var requestTimeoutId; // the id of the ^timeout\n  var ret; // the object returned to the user, might be a promise\n  var defer; // the defer object, will be set when we are using promises.\n\n  var body = params.body;\n  var headers = !params.headers\n    ? {}\n    : _.transform(params.headers, function(headers, val, name) {\n        headers[String(name).toLowerCase()] = val;\n      });\n\n  self.log.debug('starting request', params);\n\n  // determine the response based on the presense of a callback\n  if (typeof cb === 'function') {\n    // handle callbacks within a domain\n    if (process.domain) {\n      cb = process.domain.bind(cb);\n    }\n    ret = {\n      abort: abortRequest,\n    };\n  } else {\n    defer = this.defer();\n    ret = defer.promise;\n    ret.abort = abortRequest;\n  }\n\n  if (body && params.method === 'GET') {\n    utils.nextTick(\n      respond,\n      new TypeError('Body can not be sent with method \"GET\"')\n    );\n    return ret;\n  }\n\n  // serialize the body\n  if (body) {\n    var serializer = self.serializer;\n    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];\n\n    body = serializeFn.call(serializer, body);\n    if (!headers['content-type']) {\n      headers['content-type'] = serializeFn.contentType;\n    }\n  }\n\n  if (params.hasOwnProperty('maxRetries')) {\n    remainingRetries = params.maxRetries;\n  }\n\n  if (params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  const pingRequest = params.path === '/' && params.method === 'HEAD';\n  if (pingRequest) {\n    const requestParam =\n      params.hasOwnProperty('requestTimeout') && params.requestTimeout;\n    requestTimeout = requestParam || this.pingTimeout;\n  }\n\n  params.req = {\n    method: params.method,\n    path: params.path || '/',\n    query: params.query,\n    body: body,\n    headers: headers,\n  };\n\n  function sendReqWithConnection(err, _connection) {\n    if (aborted) {\n      return;\n    }\n\n    if (err) {\n      respond(err);\n    } else if (_connection) {\n      connection = _connection;\n      requestAborter = connection.request(params.req, checkRespForFailure);\n    } else {\n      self.log.warning('No living connections');\n      respond(new errors.NoConnections());\n    }\n  }\n\n  function checkRespForFailure(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    requestAborter = void 0;\n\n    if (err instanceof errors.RequestTypeError) {\n      self.log.error('Connection refused to execute the request', err);\n      respond(err, body, status, headers);\n      return;\n    }\n\n    if (err) {\n      connection.setStatus('dead');\n\n      var errMsg = err.message || '';\n\n      errMsg =\n        '\\n' +\n        params.req.method +\n        ' ' +\n        connection.host.makeUrl(params.req) +\n        (errMsg.length ? ' => ' : '') +\n        errMsg;\n\n      if (remainingRetries) {\n        remainingRetries--;\n        self.log.error('Request error, retrying' + errMsg);\n        self.connectionPool.select(sendReqWithConnection);\n      } else {\n        self.log.error('Request complete with error' + errMsg);\n        respond(new errors.ConnectionFault(err));\n      }\n    } else {\n      self.log.debug('Request complete');\n      respond(void 0, body, status, headers);\n    }\n  }\n\n  function respond(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    self._timeout(requestTimeoutId);\n    var parsedBody;\n    var isJson =\n      !headers ||\n      (headers['content-type'] &&\n        ~headers['content-type'].indexOf('application/json'));\n\n    if (!err && body) {\n      if (isJson) {\n        parsedBody = self.serializer.deserialize(body);\n        if (parsedBody == null) {\n          err = new errors.Serialization();\n          parsedBody = body;\n        }\n      } else {\n        parsedBody = body;\n      }\n    }\n\n    // does the response represent an error?\n    if (\n      (!err || err instanceof errors.Serialization) &&\n      (status < 200 || status >= 300) &&\n      (!params.ignore || !_.includes(params.ignore, status))\n    ) {\n      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);\n      errorMetadata.statusCode = status;\n      errorMetadata.response = body;\n\n      if (status === 401 && headers && headers['www-authenticate']) {\n        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];\n      }\n\n      if (errors[status]) {\n        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);\n      } else {\n        err = new errors.Generic('unknown error', errorMetadata);\n      }\n    }\n\n    // can we cast notfound to false?\n    if (params.castExists) {\n      if (err && err instanceof errors.NotFound) {\n        parsedBody = false;\n        err = void 0;\n      } else {\n        parsedBody = !err;\n      }\n    }\n\n    // how do we send the response?\n    if (typeof cb === 'function') {\n      if (err) {\n        cb(err, parsedBody, status);\n      } else {\n        cb(void 0, parsedBody, status);\n      }\n    } else if (err) {\n      err.body = parsedBody;\n      err.status = status;\n      defer.reject(err);\n    } else {\n      defer.resolve(parsedBody);\n    }\n  }\n\n  function abortRequest() {\n    if (aborted) {\n      return;\n    }\n\n    aborted = true;\n    remainingRetries = 0;\n    self._timeout(requestTimeoutId);\n    if (typeof requestAborter === 'function') {\n      requestAborter();\n    }\n  }\n\n  if (requestTimeout && requestTimeout !== Infinity) {\n    requestTimeoutId = this._timeout(function() {\n      respond(\n        new errors.RequestTimeout(\n          'Request Timeout after ' + requestTimeout + 'ms'\n        )\n      );\n      abortRequest();\n    }, requestTimeout);\n  }\n\n  if (connection) {\n    sendReqWithConnection(void 0, connection);\n  } else {\n    self.connectionPool.select(sendReqWithConnection);\n  }\n\n  return ret;\n};\n\nTransport.prototype._timeout = function(cb, delay) {\n  if (this.closed) return;\n\n  var id;\n  var timers = this._timers || (this._timers = []);\n\n  if (typeof cb !== 'function') {\n    id = cb;\n    cb = void 0;\n  }\n\n  if (cb) {\n    // set the timer\n    id = setTimeout(function() {\n      _.pull(timers, id);\n      cb();\n    }, delay);\n\n    timers.push(id);\n    return id;\n  }\n\n  if (id) {\n    clearTimeout(id);\n\n    var i = this._timers.indexOf(id);\n    if (i !== -1) {\n      this._timers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Ask an ES node for a list of all the nodes, add/remove nodes from the connection\n * pool as appropriate\n *\n * @param  {Function} cb - Function to call back once complete\n */\nTransport.prototype.sniff = function(cb) {\n  var self = this;\n  var nodesToHostCallback = this.nodesToHostCallback;\n  var log = this.log;\n  var sniffedNodesProtocol = this.sniffedNodesProtocol;\n  var sniffedNodesFilterPath = this.sniffedNodesFilterPath;\n\n  // make cb a function if it isn't\n  cb = typeof cb === 'function' ? cb : _.noop;\n\n  this.request(\n    {\n      path: this.sniffEndpoint,\n      query: { filter_path: sniffedNodesFilterPath },\n      method: 'GET',\n    },\n    function(err, resp, status) {\n      if (!err && resp && resp.nodes) {\n        var hostsConfigs;\n\n        try {\n          hostsConfigs = nodesToHostCallback(resp.nodes);\n        } catch (e) {\n          log.error(\n            new Error(\n              'Unable to convert node list from ' +\n                self.sniffEndpoint +\n                ' to hosts durring sniff. Encountered error:\\n' +\n                (e.stack || e.message)\n            )\n          );\n          return;\n        }\n\n        _.forEach(hostsConfigs, function(hostConfig) {\n          if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;\n        });\n\n        self.setHosts(hostsConfigs);\n      }\n      cb(err, resp, status);\n    }\n  );\n};\n\n/**\n * Set the host list that the transport should use.\n *\n * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects\n *                                         that will be used to create Host objects.\n */\nTransport.prototype.setHosts = function(hostsConfigs) {\n  var globalConfig = this._config;\n  this.connectionPool.setHosts(\n    _.map(hostsConfigs, function(conf) {\n      return conf instanceof Host ? conf : new Host(conf, globalConfig);\n    })\n  );\n};\n\n/**\n * Close the Transport, which closes the logs and connection pool\n * @return {[type]} [description]\n */\nTransport.prototype.close = function() {\n  this.log.close();\n  this.closed = true;\n  _.each(this._timers, clearTimeout);\n  this._timers = null;\n  this.connectionPool.close();\n};\n"]},"metadata":{},"sourceType":"script"}