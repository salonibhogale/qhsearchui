{"ast":null,"code":"/**\n * Connection that registers a module with angular, using angular's $http service\n * to communicate with ES.\n *\n * @class connections.Angular\n */\nmodule.exports = AngularConnector;\n\nvar utils = require('../utils');\n\nvar ConnectionAbstract = require('../connection');\n\nvar ConnectionFault = require('../errors').ConnectionFault;\n\nfunction AngularConnector(host, config) {\n  ConnectionAbstract.call(this, host, config);\n  var self = this;\n  config.$injector.invoke(['$http', '$q', function ($http, $q) {\n    self.$q = $q;\n    self.$http = $http;\n  }]);\n}\n\nutils.inherits(AngularConnector, ConnectionAbstract);\n\nAngularConnector.prototype.request = function (params, cb) {\n  var abort = this.$q.defer();\n  this.$http({\n    method: params.method,\n    url: this.host.makeUrl(params),\n    data: params.body,\n    cache: false,\n    headers: this.host.getHeaders(params.headers),\n    transformRequest: [],\n    transformResponse: [],\n    // not actually for timing out, that's handled by the transport\n    timeout: abort.promise\n  }).then(function (response) {\n    cb(null, response.data, response.status, response.headers());\n  }, function (err) {\n    if (err.status) {\n      cb(null, err.data, err.status, err.headers());\n    } else {\n      cb(new ConnectionFault(err.message));\n    }\n  });\n  return function () {\n    abort.resolve();\n  };\n};","map":{"version":3,"sources":["/Users/mohitkumar/github/qhsearch/new_qhsearch/node_modules/elasticsearch/src/lib/connectors/angular.js"],"names":["module","exports","AngularConnector","utils","require","ConnectionAbstract","ConnectionFault","host","config","call","self","$injector","invoke","$http","$q","inherits","prototype","request","params","cb","abort","defer","method","url","makeUrl","data","body","cache","headers","getHeaders","transformRequest","transformResponse","timeout","promise","then","response","status","err","message","resolve"],"mappings":"AAAA;;;;;;AAMAA,MAAM,CAACC,OAAP,GAAiBC,gBAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIC,kBAAkB,GAAGD,OAAO,CAAC,eAAD,CAAhC;;AACA,IAAIE,eAAe,GAAGF,OAAO,CAAC,WAAD,CAAP,CAAqBE,eAA3C;;AAEA,SAASJ,gBAAT,CAA0BK,IAA1B,EAAgCC,MAAhC,EAAwC;AACtCH,EAAAA,kBAAkB,CAACI,IAAnB,CAAwB,IAAxB,EAA8BF,IAA9B,EAAoCC,MAApC;AAEA,MAAIE,IAAI,GAAG,IAAX;AACAF,EAAAA,MAAM,CAACG,SAAP,CAAiBC,MAAjB,CAAwB,CACtB,OADsB,EAEtB,IAFsB,EAGtB,UAASC,KAAT,EAAgBC,EAAhB,EAAoB;AAClBJ,IAAAA,IAAI,CAACI,EAAL,GAAUA,EAAV;AACAJ,IAAAA,IAAI,CAACG,KAAL,GAAaA,KAAb;AACD,GANqB,CAAxB;AAQD;;AACDV,KAAK,CAACY,QAAN,CAAeb,gBAAf,EAAiCG,kBAAjC;;AAEAH,gBAAgB,CAACc,SAAjB,CAA2BC,OAA3B,GAAqC,UAASC,MAAT,EAAiBC,EAAjB,EAAqB;AACxD,MAAIC,KAAK,GAAG,KAAKN,EAAL,CAAQO,KAAR,EAAZ;AAEA,OAAKR,KAAL,CAAW;AACTS,IAAAA,MAAM,EAAEJ,MAAM,CAACI,MADN;AAETC,IAAAA,GAAG,EAAE,KAAKhB,IAAL,CAAUiB,OAAV,CAAkBN,MAAlB,CAFI;AAGTO,IAAAA,IAAI,EAAEP,MAAM,CAACQ,IAHJ;AAITC,IAAAA,KAAK,EAAE,KAJE;AAKTC,IAAAA,OAAO,EAAE,KAAKrB,IAAL,CAAUsB,UAAV,CAAqBX,MAAM,CAACU,OAA5B,CALA;AAMTE,IAAAA,gBAAgB,EAAE,EANT;AAOTC,IAAAA,iBAAiB,EAAE,EAPV;AAQT;AACAC,IAAAA,OAAO,EAAEZ,KAAK,CAACa;AATN,GAAX,EAUGC,IAVH,CAWE,UAASC,QAAT,EAAmB;AACjBhB,IAAAA,EAAE,CAAC,IAAD,EAAOgB,QAAQ,CAACV,IAAhB,EAAsBU,QAAQ,CAACC,MAA/B,EAAuCD,QAAQ,CAACP,OAAT,EAAvC,CAAF;AACD,GAbH,EAcE,UAASS,GAAT,EAAc;AACZ,QAAIA,GAAG,CAACD,MAAR,EAAgB;AACdjB,MAAAA,EAAE,CAAC,IAAD,EAAOkB,GAAG,CAACZ,IAAX,EAAiBY,GAAG,CAACD,MAArB,EAA6BC,GAAG,CAACT,OAAJ,EAA7B,CAAF;AACD,KAFD,MAEO;AACLT,MAAAA,EAAE,CAAC,IAAIb,eAAJ,CAAoB+B,GAAG,CAACC,OAAxB,CAAD,CAAF;AACD;AACF,GApBH;AAuBA,SAAO,YAAW;AAChBlB,IAAAA,KAAK,CAACmB,OAAN;AACD,GAFD;AAGD,CA7BD","sourcesContent":["/**\n * Connection that registers a module with angular, using angular's $http service\n * to communicate with ES.\n *\n * @class connections.Angular\n */\nmodule.exports = AngularConnector;\n\nvar utils = require('../utils');\nvar ConnectionAbstract = require('../connection');\nvar ConnectionFault = require('../errors').ConnectionFault;\n\nfunction AngularConnector(host, config) {\n  ConnectionAbstract.call(this, host, config);\n\n  var self = this;\n  config.$injector.invoke([\n    '$http',\n    '$q',\n    function($http, $q) {\n      self.$q = $q;\n      self.$http = $http;\n    },\n  ]);\n}\nutils.inherits(AngularConnector, ConnectionAbstract);\n\nAngularConnector.prototype.request = function(params, cb) {\n  var abort = this.$q.defer();\n\n  this.$http({\n    method: params.method,\n    url: this.host.makeUrl(params),\n    data: params.body,\n    cache: false,\n    headers: this.host.getHeaders(params.headers),\n    transformRequest: [],\n    transformResponse: [],\n    // not actually for timing out, that's handled by the transport\n    timeout: abort.promise,\n  }).then(\n    function(response) {\n      cb(null, response.data, response.status, response.headers());\n    },\n    function(err) {\n      if (err.status) {\n        cb(null, err.data, err.status, err.headers());\n      } else {\n        cb(new ConnectionFault(err.message));\n      }\n    }\n  );\n\n  return function() {\n    abort.resolve();\n  };\n};\n"]},"metadata":{},"sourceType":"script"}