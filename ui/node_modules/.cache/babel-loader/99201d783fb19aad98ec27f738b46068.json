{"ast":null,"code":"/**\n * Manager of connections to a node(s), capable of ensuring that connections are clear and living\n * before providing them to the application\n *\n * @class ConnectionPool\n * @constructor\n * @param {Object} config - The config object passed to the transport.\n */\nmodule.exports = ConnectionPool;\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar Log = require('./log');\n\nfunction ConnectionPool(config) {\n  config = config || {};\n  utils.makeBoundMethods(this);\n\n  if (!config.log) {\n    this.log = new Log();\n    config.log = this.log;\n  } else {\n    this.log = config.log;\n  } // we will need this when we create connections down the road\n\n\n  this._config = config; // get the selector config var\n\n  this.selector = utils.funcEnum(config, 'selector', ConnectionPool.selectors, ConnectionPool.defaultSelector); // get the connection class\n\n  this.Connection = utils.funcEnum(config, 'connectionClass', ConnectionPool.connectionClasses, ConnectionPool.defaultConnectionClass); // time that connections will wait before being revived\n\n  this.deadTimeout = config.hasOwnProperty('deadTimeout') ? config.deadTimeout : 60000;\n  this.maxDeadTimeout = config.hasOwnProperty('maxDeadTimeout') ? config.maxDeadTimeout : 18e5;\n  this.calcDeadTimeout = utils.funcEnum(config, 'calcDeadTimeout', ConnectionPool.calcDeadTimeoutOptions, 'exponential'); // a map of connections to their \"id\" property, used when sniffing\n\n  this.index = {};\n  this._conns = {\n    alive: [],\n    dead: []\n  }; // information about timeouts for dead connections\n\n  this._timeouts = [];\n} // selector options\n\n\nConnectionPool.selectors = require('./selectors');\nConnectionPool.defaultSelector = 'roundRobin'; // get the connection options\n\nConnectionPool.connectionClasses = require('./connectors');\nConnectionPool.defaultConnectionClass = ConnectionPool.connectionClasses._default;\ndelete ConnectionPool.connectionClasses._default; // the function that calculates timeouts based on attempts\n\nConnectionPool.calcDeadTimeoutOptions = {\n  flat: function (attempt, baseTimeout) {\n    return baseTimeout;\n  },\n  exponential: function (attempt, baseTimeout) {\n    return Math.min(baseTimeout * 2 * Math.pow(2, attempt * 0.5 - 1), this.maxDeadTimeout);\n  }\n};\n/**\n * Selects a connection from the list using the this.selector\n * Features:\n *  - detects if the selector is async or not\n *  - sync selectors should still return asynchronously\n *  - catches errors in sync selectors\n *  - automatically selects the first dead connection when there no living connections\n *\n * @param  {Function} cb [description]\n * @return {[type]}      [description]\n */\n\nConnectionPool.prototype.select = function (cb) {\n  if (this._conns.alive.length) {\n    if (this.selector.length > 1) {\n      this.selector(this._conns.alive, cb);\n    } else {\n      try {\n        utils.nextTick(cb, void 0, this.selector(this._conns.alive));\n      } catch (e) {\n        cb(e);\n      }\n    }\n  } else if (this._timeouts.length) {\n    this._selectDeadConnection(cb);\n  } else {\n    utils.nextTick(cb, void 0);\n  }\n};\n/**\n * Handler for the \"set status\" event emitted but the connections. It will move\n * the connection to it's proper connection list (unless it was closed).\n *\n * @param  {String} status - the connection's new status\n * @param  {String} oldStatus - the connection's old status\n * @param  {ConnectionAbstract} connection - the connection object itself\n */\n\n\nConnectionPool.prototype.onStatusSet = utils.handler(function (status, oldStatus, connection) {\n  var index;\n  var died = status === 'dead';\n  var wasAlreadyDead = died && oldStatus === 'dead';\n  var revived = !died && oldStatus === 'dead';\n  var noChange = oldStatus === status;\n  var from = this._conns[oldStatus];\n  var to = this._conns[status];\n\n  if (noChange && !died) {\n    return true;\n  }\n\n  if (from !== to) {\n    if (_.isArray(from)) {\n      index = from.indexOf(connection);\n\n      if (index !== -1) {\n        from.splice(index, 1);\n      }\n    }\n\n    if (_.isArray(to)) {\n      index = to.indexOf(connection);\n\n      if (index === -1) {\n        to.push(connection);\n      }\n    }\n  }\n\n  if (died) {\n    this._onConnectionDied(connection, wasAlreadyDead);\n  }\n\n  if (revived) {\n    this._onConnectionRevived(connection);\n  }\n});\n/**\n * Handler used to clear the times created when a connection dies\n * @param  {ConnectionAbstract} connection\n */\n\nConnectionPool.prototype._onConnectionRevived = function (connection) {\n  var timeout;\n\n  for (var i = 0; i < this._timeouts.length; i++) {\n    if (this._timeouts[i].conn === connection) {\n      timeout = this._timeouts[i];\n\n      if (timeout.id) {\n        clearTimeout(timeout.id);\n      }\n\n      this._timeouts.splice(i, 1);\n\n      break;\n    }\n  }\n};\n/**\n * Handler used to update or create a timeout for the connection which has died\n * @param  {ConnectionAbstract} connection\n * @param  {Boolean} alreadyWasDead - If the connection was preivously dead this must be set to true\n */\n\n\nConnectionPool.prototype._onConnectionDied = function (connection, alreadyWasDead) {\n  var timeout;\n\n  if (alreadyWasDead) {\n    for (var i = 0; i < this._timeouts.length; i++) {\n      if (this._timeouts[i].conn === connection) {\n        timeout = this._timeouts[i];\n        break;\n      }\n    }\n  } else {\n    timeout = {\n      conn: connection,\n      attempt: 0,\n      revive: function (cb) {\n        timeout.attempt++;\n        connection.ping(function (err) {\n          connection.setStatus(err ? 'dead' : 'alive');\n\n          if (cb && typeof cb === 'function') {\n            cb(err);\n          }\n        });\n      }\n    };\n\n    this._timeouts.push(timeout);\n  }\n\n  if (timeout.id) {\n    clearTimeout(timeout.id);\n  }\n\n  var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);\n  timeout.id = setTimeout(timeout.revive, ms);\n  timeout.runAt = utils.now() + ms;\n};\n\nConnectionPool.prototype._selectDeadConnection = function (cb) {\n  var orderedTimeouts = _.sortBy(this._timeouts, 'runAt');\n\n  var log = this.log;\n  process.nextTick(function next() {\n    var timeout = orderedTimeouts.shift();\n\n    if (!timeout) {\n      cb(void 0);\n      return;\n    }\n\n    if (!timeout.conn) {\n      next();\n      return;\n    }\n\n    if (timeout.conn.status === 'dead') {\n      timeout.revive(function (err) {\n        if (err) {\n          log.warning('Unable to revive connection: ' + timeout.conn.id);\n          process.nextTick(next);\n        } else {\n          cb(void 0, timeout.conn);\n        }\n      });\n    } else {\n      cb(void 0, timeout.conn);\n    }\n  });\n};\n/**\n * Returns a random list of nodes from the living connections up to the limit.\n * If there are no living connections it will fall back to the dead connections.\n * If there are no dead connections it will return nothing.\n *\n * This is used for testing (when we just want the one existing node)\n * and sniffing, where using the selector to get all of the living connections\n * is not reasonable.\n *\n * @param {string} [status] - optional status of the connection to fetch\n * @param {Number} [limit] - optional limit on the number of connections to return\n */\n\n\nConnectionPool.prototype.getConnections = function (status, limit) {\n  var list;\n\n  if (status) {\n    list = this._conns[status];\n  } else {\n    list = this._conns[this._conns.alive.length ? 'alive' : 'dead'];\n  }\n\n  if (limit == null) {\n    return list.slice(0);\n  } else {\n    return _.shuffle(list).slice(0, limit);\n  }\n};\n/**\n * Add a single connection to the pool and change it's status to \"alive\".\n * The connection should inherit from ConnectionAbstract\n *\n * @param {ConnectionAbstract} connection - The connection to add\n */\n\n\nConnectionPool.prototype.addConnection = function (connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (!this.index[connection.id]) {\n    this.log.info('Adding connection to', connection.id);\n    this.index[connection.id] = connection;\n    connection.on('status set', this.bound.onStatusSet);\n    connection.setStatus('alive');\n  }\n};\n/**\n * Remove a connection from the pool, and set it's status to \"closed\".\n *\n * @param  {ConnectionAbstract} connection - The connection to remove/close\n */\n\n\nConnectionPool.prototype.removeConnection = function (connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (this.index[connection.id]) {\n    delete this.index[connection.id];\n    connection.setStatus('closed');\n    connection.removeListener('status set', this.bound.onStatusSet);\n  }\n};\n/**\n * Override the internal node list. All connections that are not in the new host\n * list are closed and removed. Non-unique hosts are ignored.\n *\n * @param {Host[]} hosts - An array of Host instances.\n */\n\n\nConnectionPool.prototype.setHosts = function (hosts) {\n  var connection;\n  var i;\n  var id;\n  var host;\n\n  var toRemove = _.clone(this.index);\n\n  for (i = 0; i < hosts.length; i++) {\n    host = hosts[i];\n    id = host.toString();\n\n    if (this.index[id]) {\n      delete toRemove[id];\n    } else {\n      connection = new this.Connection(host, this._config);\n      connection.id = id;\n      this.addConnection(connection);\n    }\n  }\n\n  var removeIds = _.keys(toRemove);\n\n  for (i = 0; i < removeIds.length; i++) {\n    this.removeConnection(this.index[removeIds[i]]);\n  }\n};\n\nConnectionPool.prototype.getAllHosts = function () {\n  return _.values(this.index).map(function (connection) {\n    return connection.host;\n  });\n};\n/**\n * Close the conncetion pool, as well as all of it's connections\n */\n\n\nConnectionPool.prototype.close = function () {\n  this.setHosts([]);\n};\n\nConnectionPool.prototype.empty = ConnectionPool.prototype.close;","map":{"version":3,"sources":["/Users/salonibhogale/qhsearchui/node_modules/elasticsearch/src/lib/connection_pool.js"],"names":["module","exports","ConnectionPool","_","require","utils","Log","config","makeBoundMethods","log","_config","selector","funcEnum","selectors","defaultSelector","Connection","connectionClasses","defaultConnectionClass","deadTimeout","hasOwnProperty","maxDeadTimeout","calcDeadTimeout","calcDeadTimeoutOptions","index","_conns","alive","dead","_timeouts","_default","flat","attempt","baseTimeout","exponential","Math","min","pow","prototype","select","cb","length","nextTick","e","_selectDeadConnection","onStatusSet","handler","status","oldStatus","connection","died","wasAlreadyDead","revived","noChange","from","to","isArray","indexOf","splice","push","_onConnectionDied","_onConnectionRevived","timeout","i","conn","id","clearTimeout","alreadyWasDead","revive","ping","err","setStatus","ms","setTimeout","runAt","now","orderedTimeouts","sortBy","process","next","shift","warning","getConnections","limit","list","slice","shuffle","addConnection","host","toString","info","on","bound","removeConnection","removeListener","setHosts","hosts","toRemove","clone","removeIds","keys","getAllHosts","values","map","close","empty"],"mappings":"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","sourcesContent":["/**\n * Manager of connections to a node(s), capable of ensuring that connections are clear and living\n * before providing them to the application\n *\n * @class ConnectionPool\n * @constructor\n * @param {Object} config - The config object passed to the transport.\n */\n\nmodule.exports = ConnectionPool;\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar Log = require('./log');\n\nfunction ConnectionPool(config) {\n  config = config || {};\n  utils.makeBoundMethods(this);\n\n  if (!config.log) {\n    this.log = new Log();\n    config.log = this.log;\n  } else {\n    this.log = config.log;\n  }\n\n  // we will need this when we create connections down the road\n  this._config = config;\n\n  // get the selector config var\n  this.selector = utils.funcEnum(\n    config,\n    'selector',\n    ConnectionPool.selectors,\n    ConnectionPool.defaultSelector\n  );\n\n  // get the connection class\n  this.Connection = utils.funcEnum(\n    config,\n    'connectionClass',\n    ConnectionPool.connectionClasses,\n    ConnectionPool.defaultConnectionClass\n  );\n\n  // time that connections will wait before being revived\n  this.deadTimeout = config.hasOwnProperty('deadTimeout')\n    ? config.deadTimeout\n    : 60000;\n  this.maxDeadTimeout = config.hasOwnProperty('maxDeadTimeout')\n    ? config.maxDeadTimeout\n    : 18e5;\n  this.calcDeadTimeout = utils.funcEnum(\n    config,\n    'calcDeadTimeout',\n    ConnectionPool.calcDeadTimeoutOptions,\n    'exponential'\n  );\n\n  // a map of connections to their \"id\" property, used when sniffing\n  this.index = {};\n\n  this._conns = {\n    alive: [],\n    dead: [],\n  };\n\n  // information about timeouts for dead connections\n  this._timeouts = [];\n}\n\n// selector options\nConnectionPool.selectors = require('./selectors');\nConnectionPool.defaultSelector = 'roundRobin';\n\n// get the connection options\nConnectionPool.connectionClasses = require('./connectors');\nConnectionPool.defaultConnectionClass =\n  ConnectionPool.connectionClasses._default;\ndelete ConnectionPool.connectionClasses._default;\n\n// the function that calculates timeouts based on attempts\nConnectionPool.calcDeadTimeoutOptions = {\n  flat: function(attempt, baseTimeout) {\n    return baseTimeout;\n  },\n  exponential: function(attempt, baseTimeout) {\n    return Math.min(\n      baseTimeout * 2 * Math.pow(2, attempt * 0.5 - 1),\n      this.maxDeadTimeout\n    );\n  },\n};\n\n/**\n * Selects a connection from the list using the this.selector\n * Features:\n *  - detects if the selector is async or not\n *  - sync selectors should still return asynchronously\n *  - catches errors in sync selectors\n *  - automatically selects the first dead connection when there no living connections\n *\n * @param  {Function} cb [description]\n * @return {[type]}      [description]\n */\nConnectionPool.prototype.select = function(cb) {\n  if (this._conns.alive.length) {\n    if (this.selector.length > 1) {\n      this.selector(this._conns.alive, cb);\n    } else {\n      try {\n        utils.nextTick(cb, void 0, this.selector(this._conns.alive));\n      } catch (e) {\n        cb(e);\n      }\n    }\n  } else if (this._timeouts.length) {\n    this._selectDeadConnection(cb);\n  } else {\n    utils.nextTick(cb, void 0);\n  }\n};\n\n/**\n * Handler for the \"set status\" event emitted but the connections. It will move\n * the connection to it's proper connection list (unless it was closed).\n *\n * @param  {String} status - the connection's new status\n * @param  {String} oldStatus - the connection's old status\n * @param  {ConnectionAbstract} connection - the connection object itself\n */\nConnectionPool.prototype.onStatusSet = utils.handler(function(\n  status,\n  oldStatus,\n  connection\n) {\n  var index;\n\n  var died = status === 'dead';\n  var wasAlreadyDead = died && oldStatus === 'dead';\n  var revived = !died && oldStatus === 'dead';\n  var noChange = oldStatus === status;\n  var from = this._conns[oldStatus];\n  var to = this._conns[status];\n\n  if (noChange && !died) {\n    return true;\n  }\n\n  if (from !== to) {\n    if (_.isArray(from)) {\n      index = from.indexOf(connection);\n      if (index !== -1) {\n        from.splice(index, 1);\n      }\n    }\n\n    if (_.isArray(to)) {\n      index = to.indexOf(connection);\n      if (index === -1) {\n        to.push(connection);\n      }\n    }\n  }\n\n  if (died) {\n    this._onConnectionDied(connection, wasAlreadyDead);\n  }\n\n  if (revived) {\n    this._onConnectionRevived(connection);\n  }\n});\n\n/**\n * Handler used to clear the times created when a connection dies\n * @param  {ConnectionAbstract} connection\n */\nConnectionPool.prototype._onConnectionRevived = function(connection) {\n  var timeout;\n  for (var i = 0; i < this._timeouts.length; i++) {\n    if (this._timeouts[i].conn === connection) {\n      timeout = this._timeouts[i];\n      if (timeout.id) {\n        clearTimeout(timeout.id);\n      }\n      this._timeouts.splice(i, 1);\n      break;\n    }\n  }\n};\n\n/**\n * Handler used to update or create a timeout for the connection which has died\n * @param  {ConnectionAbstract} connection\n * @param  {Boolean} alreadyWasDead - If the connection was preivously dead this must be set to true\n */\nConnectionPool.prototype._onConnectionDied = function(\n  connection,\n  alreadyWasDead\n) {\n  var timeout;\n  if (alreadyWasDead) {\n    for (var i = 0; i < this._timeouts.length; i++) {\n      if (this._timeouts[i].conn === connection) {\n        timeout = this._timeouts[i];\n        break;\n      }\n    }\n  } else {\n    timeout = {\n      conn: connection,\n      attempt: 0,\n      revive: function(cb) {\n        timeout.attempt++;\n        connection.ping(function(err) {\n          connection.setStatus(err ? 'dead' : 'alive');\n          if (cb && typeof cb === 'function') {\n            cb(err);\n          }\n        });\n      },\n    };\n    this._timeouts.push(timeout);\n  }\n\n  if (timeout.id) {\n    clearTimeout(timeout.id);\n  }\n\n  var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);\n  timeout.id = setTimeout(timeout.revive, ms);\n  timeout.runAt = utils.now() + ms;\n};\n\nConnectionPool.prototype._selectDeadConnection = function(cb) {\n  var orderedTimeouts = _.sortBy(this._timeouts, 'runAt');\n  var log = this.log;\n\n  process.nextTick(function next() {\n    var timeout = orderedTimeouts.shift();\n    if (!timeout) {\n      cb(void 0);\n      return;\n    }\n\n    if (!timeout.conn) {\n      next();\n      return;\n    }\n\n    if (timeout.conn.status === 'dead') {\n      timeout.revive(function(err) {\n        if (err) {\n          log.warning('Unable to revive connection: ' + timeout.conn.id);\n          process.nextTick(next);\n        } else {\n          cb(void 0, timeout.conn);\n        }\n      });\n    } else {\n      cb(void 0, timeout.conn);\n    }\n  });\n};\n\n/**\n * Returns a random list of nodes from the living connections up to the limit.\n * If there are no living connections it will fall back to the dead connections.\n * If there are no dead connections it will return nothing.\n *\n * This is used for testing (when we just want the one existing node)\n * and sniffing, where using the selector to get all of the living connections\n * is not reasonable.\n *\n * @param {string} [status] - optional status of the connection to fetch\n * @param {Number} [limit] - optional limit on the number of connections to return\n */\nConnectionPool.prototype.getConnections = function(status, limit) {\n  var list;\n  if (status) {\n    list = this._conns[status];\n  } else {\n    list = this._conns[this._conns.alive.length ? 'alive' : 'dead'];\n  }\n\n  if (limit == null) {\n    return list.slice(0);\n  } else {\n    return _.shuffle(list).slice(0, limit);\n  }\n};\n\n/**\n * Add a single connection to the pool and change it's status to \"alive\".\n * The connection should inherit from ConnectionAbstract\n *\n * @param {ConnectionAbstract} connection - The connection to add\n */\nConnectionPool.prototype.addConnection = function(connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (!this.index[connection.id]) {\n    this.log.info('Adding connection to', connection.id);\n    this.index[connection.id] = connection;\n    connection.on('status set', this.bound.onStatusSet);\n    connection.setStatus('alive');\n  }\n};\n\n/**\n * Remove a connection from the pool, and set it's status to \"closed\".\n *\n * @param  {ConnectionAbstract} connection - The connection to remove/close\n */\nConnectionPool.prototype.removeConnection = function(connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (this.index[connection.id]) {\n    delete this.index[connection.id];\n    connection.setStatus('closed');\n    connection.removeListener('status set', this.bound.onStatusSet);\n  }\n};\n\n/**\n * Override the internal node list. All connections that are not in the new host\n * list are closed and removed. Non-unique hosts are ignored.\n *\n * @param {Host[]} hosts - An array of Host instances.\n */\nConnectionPool.prototype.setHosts = function(hosts) {\n  var connection;\n  var i;\n  var id;\n  var host;\n  var toRemove = _.clone(this.index);\n\n  for (i = 0; i < hosts.length; i++) {\n    host = hosts[i];\n    id = host.toString();\n    if (this.index[id]) {\n      delete toRemove[id];\n    } else {\n      connection = new this.Connection(host, this._config);\n      connection.id = id;\n      this.addConnection(connection);\n    }\n  }\n\n  var removeIds = _.keys(toRemove);\n  for (i = 0; i < removeIds.length; i++) {\n    this.removeConnection(this.index[removeIds[i]]);\n  }\n};\n\nConnectionPool.prototype.getAllHosts = function() {\n  return _.values(this.index).map(function(connection) {\n    return connection.host;\n  });\n};\n\n/**\n * Close the conncetion pool, as well as all of it's connections\n */\nConnectionPool.prototype.close = function() {\n  this.setHosts([]);\n};\nConnectionPool.prototype.empty = ConnectionPool.prototype.close;\n"]},"metadata":{},"sourceType":"script"}