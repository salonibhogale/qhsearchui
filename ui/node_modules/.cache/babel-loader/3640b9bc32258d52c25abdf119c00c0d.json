{"ast":null,"code":"var utils = require('../utils');\n/**\n * Patch the transport's connection pool to schedule a sniff after a connection fails.\n * When a connection fails for the first time it will schedule a sniff 1 second in the\n * future, and increase the timeout based on the deadTimeout algorithm chosen by the\n * connectionPool, and the number of times the sniff has failed.\n *\n * @param  {Transport} transport - the transport that will be using this behavior\n * @return {undefined}\n */\n\n\nmodule.exports = function setupSniffOnConnectionFault(transport) {\n  var failures = 0;\n  var pool = transport.connectionPool;\n  var originalOnDied = pool._onConnectionDied; // do the actual sniff, if the sniff is unable to\n  // connect to a node this function will be called again by the connectionPool\n\n  var work = function () {\n    work.timerId = transport._timeout(work.timerId);\n    transport.sniff();\n  }; // create a function that will count down to a\n  // point n milliseconds into the future\n\n\n  var countdownTo = function (ms) {\n    var start = utils.now();\n    return function () {\n      return start - ms;\n    };\n  }; // overwrite the function, but still call it\n\n\n  pool._onConnectionDied = function (connection, wasAlreadyDead) {\n    var ret = originalOnDied.call(pool, connection, wasAlreadyDead); // clear the failures if this is the first failure we have seen\n\n    failures = work.timerId ? failures + 1 : 0;\n    var ms = pool.calcDeadTimeout(failures, 1000);\n\n    if (work.timerId && ms < work.timerId && work.countdown()) {\n      // clear the timer\n      work.timerId = transport._timeout(work.timerId);\n    }\n\n    if (!work.timerId) {\n      work.timerId = transport._timeout(work, ms);\n      work.countdown = countdownTo(ms);\n    }\n\n    return ret;\n  };\n\n  pool._onConnectionDied.restore = function () {\n    pool._onConnectionDied = originalOnDied;\n  };\n};","map":{"version":3,"sources":["/Users/salonibhogale/qhsearchui/node_modules/elasticsearch/src/lib/transport/sniff_on_connection_fault.js"],"names":["utils","require","module","exports","setupSniffOnConnectionFault","transport","failures","pool","connectionPool","originalOnDied","_onConnectionDied","work","timerId","_timeout","sniff","countdownTo","ms","start","now","connection","wasAlreadyDead","ret","call","calcDeadTimeout","countdown","restore"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAAnB;AAEA;;;;;;;;;;;AASAC,MAAM,CAACC,OAAP,GAAiB,SAASC,2BAAT,CAAqCC,SAArC,EAAgD;AAC/D,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,IAAI,GAAGF,SAAS,CAACG,cAArB;AACA,MAAIC,cAAc,GAAGF,IAAI,CAACG,iBAA1B,CAH+D,CAK/D;AACA;;AACA,MAAIC,IAAI,GAAG,YAAW;AACpBA,IAAAA,IAAI,CAACC,OAAL,GAAeP,SAAS,CAACQ,QAAV,CAAmBF,IAAI,CAACC,OAAxB,CAAf;AACAP,IAAAA,SAAS,CAACS,KAAV;AACD,GAHD,CAP+D,CAY/D;AACA;;;AACA,MAAIC,WAAW,GAAG,UAASC,EAAT,EAAa;AAC7B,QAAIC,KAAK,GAAGjB,KAAK,CAACkB,GAAN,EAAZ;AACA,WAAO,YAAW;AAChB,aAAOD,KAAK,GAAGD,EAAf;AACD,KAFD;AAGD,GALD,CAd+D,CAqB/D;;;AACAT,EAAAA,IAAI,CAACG,iBAAL,GAAyB,UAASS,UAAT,EAAqBC,cAArB,EAAqC;AAC5D,QAAIC,GAAG,GAAGZ,cAAc,CAACa,IAAf,CAAoBf,IAApB,EAA0BY,UAA1B,EAAsCC,cAAtC,CAAV,CAD4D,CAG5D;;AACAd,IAAAA,QAAQ,GAAGK,IAAI,CAACC,OAAL,GAAeN,QAAQ,GAAG,CAA1B,GAA8B,CAAzC;AAEA,QAAIU,EAAE,GAAGT,IAAI,CAACgB,eAAL,CAAqBjB,QAArB,EAA+B,IAA/B,CAAT;;AAEA,QAAIK,IAAI,CAACC,OAAL,IAAgBI,EAAE,GAAGL,IAAI,CAACC,OAA1B,IAAqCD,IAAI,CAACa,SAAL,EAAzC,EAA2D;AACzD;AACAb,MAAAA,IAAI,CAACC,OAAL,GAAeP,SAAS,CAACQ,QAAV,CAAmBF,IAAI,CAACC,OAAxB,CAAf;AACD;;AAED,QAAI,CAACD,IAAI,CAACC,OAAV,EAAmB;AACjBD,MAAAA,IAAI,CAACC,OAAL,GAAeP,SAAS,CAACQ,QAAV,CAAmBF,IAAnB,EAAyBK,EAAzB,CAAf;AACAL,MAAAA,IAAI,CAACa,SAAL,GAAiBT,WAAW,CAACC,EAAD,CAA5B;AACD;;AAED,WAAOK,GAAP;AACD,GAnBD;;AAqBAd,EAAAA,IAAI,CAACG,iBAAL,CAAuBe,OAAvB,GAAiC,YAAW;AAC1ClB,IAAAA,IAAI,CAACG,iBAAL,GAAyBD,cAAzB;AACD,GAFD;AAGD,CA9CD","sourcesContent":["var utils = require('../utils');\n\n/**\n * Patch the transport's connection pool to schedule a sniff after a connection fails.\n * When a connection fails for the first time it will schedule a sniff 1 second in the\n * future, and increase the timeout based on the deadTimeout algorithm chosen by the\n * connectionPool, and the number of times the sniff has failed.\n *\n * @param  {Transport} transport - the transport that will be using this behavior\n * @return {undefined}\n */\nmodule.exports = function setupSniffOnConnectionFault(transport) {\n  var failures = 0;\n  var pool = transport.connectionPool;\n  var originalOnDied = pool._onConnectionDied;\n\n  // do the actual sniff, if the sniff is unable to\n  // connect to a node this function will be called again by the connectionPool\n  var work = function() {\n    work.timerId = transport._timeout(work.timerId);\n    transport.sniff();\n  };\n\n  // create a function that will count down to a\n  // point n milliseconds into the future\n  var countdownTo = function(ms) {\n    var start = utils.now();\n    return function() {\n      return start - ms;\n    };\n  };\n\n  // overwrite the function, but still call it\n  pool._onConnectionDied = function(connection, wasAlreadyDead) {\n    var ret = originalOnDied.call(pool, connection, wasAlreadyDead);\n\n    // clear the failures if this is the first failure we have seen\n    failures = work.timerId ? failures + 1 : 0;\n\n    var ms = pool.calcDeadTimeout(failures, 1000);\n\n    if (work.timerId && ms < work.timerId && work.countdown()) {\n      // clear the timer\n      work.timerId = transport._timeout(work.timerId);\n    }\n\n    if (!work.timerId) {\n      work.timerId = transport._timeout(work, ms);\n      work.countdown = countdownTo(ms);\n    }\n\n    return ret;\n  };\n\n  pool._onConnectionDied.restore = function() {\n    pool._onConnectionDied = originalOnDied;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}