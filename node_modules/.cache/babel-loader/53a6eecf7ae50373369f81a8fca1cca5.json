{"ast":null,"code":"import * as moment from \"moment\";\nimport { identity } from \"lodash\";\nimport { ObjectState, FilterBucket, BoolMust, FieldContextFactory, FilterBasedAccessor } from \"searchkit\";\nimport { DateRangeQuery } from \"./DateRangeQuery\";\nexport class DateRangeAccessor extends FilterBasedAccessor {\n  constructor(key, options) {\n    super(key, options.id);\n    this.options = void 0;\n    this.state = new ObjectState({});\n    this.fieldContext = void 0;\n    this.rangeFormatter = void 0;\n\n    this.clearState = () => {\n      // Need to pass state reset through parent component so view can be updated\n      this.options.onClearState();\n    };\n\n    this.options = options;\n    this.options.fieldOptions = this.options.fieldOptions || {\n      type: \"embedded\"\n    };\n    this.fieldContext = FieldContextFactory(this.options.fieldOptions);\n    this.rangeFormatter = this.options.rangeFormatter || identity;\n    const {\n      fromDate,\n      toDate\n    } = options;\n\n    if (fromDate || toDate) {\n      this.state = this.state.setValue({\n        fromDate,\n        toDate\n      });\n    }\n  }\n\n  fromQueryObject(ob) {\n    let fromValue = ob[this.urlKey + '_from'];\n    let toValue = ob[this.urlKey + '_to'];\n\n    if (fromValue || toValue) {\n      this.state = this.state.setValue({\n        fromDate: fromValue && moment(+fromValue),\n        toDate: toValue && moment(+toValue)\n      });\n    }\n  }\n\n  getQueryObject() {\n    let val = this.state.getValue();\n    let fromDate = val.fromDate && +val.fromDate;\n    let toDate = val.toDate && +val.toDate;\n    return val ? {\n      [this.urlKey + '_from']: fromDate,\n      [this.urlKey + '_to']: toDate\n    } : {};\n  }\n\n  buildSharedQuery(query) {\n    if (this.state.hasValue()) {\n      let val = this.state.getValue();\n      let fromDateRangeFilter = this.fieldContext.wrapFilter(DateRangeQuery(this.options.fromDateField, {\n        lte: +val.toDate\n      }));\n      let toDateRangeFilter = this.fieldContext.wrapFilter(DateRangeQuery(this.options.toDateField, {\n        gte: +val.fromDate\n      }));\n      const fromVal = this.rangeFormatter(val.fromDate);\n      const toVal = this.rangeFormatter(val.toDate);\n      const selectedFilterText = val.toDate ? `${fromVal} – ${toVal}` : `${fromVal} –`;\n      let selectedFilter = {\n        name: this.translate(this.options.title),\n        value: selectedFilterText,\n        id: this.options.id,\n        remove: this.clearState\n      };\n      return query.addFilter(this.key + '_to', fromDateRangeFilter).addFilter(this.key + '_from', toDateRangeFilter).addSelectedFilter(selectedFilter);\n    }\n\n    return query;\n  }\n\n  getBuckets() {\n    return this.getAggregations([this.key, this.fieldContext.getAggregationPath(), this.key, \"buckets\"], []);\n  }\n\n  isDisabled() {\n    // This accessor is never \"disabled\"; the calendar should always be visible\n    return false;\n  }\n\n  buildOwnQuery(query) {\n    if (this.state.hasValue()) {\n      let val = this.state.getValue();\n      let otherFilters = query.getFiltersWithoutKeys(this.key);\n      let filters = BoolMust([otherFilters, this.fieldContext.wrapFilter(DateRangeQuery(this.options.fromDateField, {\n        lte: +val.toDate\n      })), this.fieldContext.wrapFilter(DateRangeQuery(this.options.toDateField, {\n        gte: +val.fromDate\n      }))]);\n      query = query.setAggs(FilterBucket(this.key, filters));\n    }\n\n    return query;\n  }\n\n}","map":{"version":3,"sources":["/Users/salonibhogale/qhsearchui/src/Components/datefilter/DateRangeAccessor.ts"],"names":["moment","identity","ObjectState","FilterBucket","BoolMust","FieldContextFactory","FilterBasedAccessor","DateRangeQuery","DateRangeAccessor","constructor","key","options","id","state","fieldContext","rangeFormatter","clearState","onClearState","fieldOptions","type","fromDate","toDate","setValue","fromQueryObject","ob","fromValue","urlKey","toValue","getQueryObject","val","getValue","buildSharedQuery","query","hasValue","fromDateRangeFilter","wrapFilter","fromDateField","lte","toDateRangeFilter","toDateField","gte","fromVal","toVal","selectedFilterText","selectedFilter","name","translate","title","value","remove","addFilter","addSelectedFilter","getBuckets","getAggregations","getAggregationPath","isDisabled","buildOwnQuery","otherFilters","getFiltersWithoutKeys","filters","setAggs"],"mappings":"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","sourcesContent":["import * as moment from \"moment\";\nimport { get, identity } from \"lodash\"\nimport {\n  ObjectState,\n  FilterBucket,\n  BoolMust,\n  FieldOptions,\n  FieldContext,\n  FieldContextFactory,\n  FilterBasedAccessor,\n} from \"searchkit\";\n\nimport { DateRangeQuery } from \"./DateRangeQuery\";\n\nexport interface DateRangeAccessorOptions {\n  title:string\n  id:string\n  fromDate:moment.Moment\n  toDate:moment.Moment\n  interval?: number\n  fromDateField:string\n  toDateField:string\n  loadHistogram?:boolean\n  fieldOptions?:FieldOptions\n  rangeFormatter?:(count:number)=> number | string\n  onClearState?:(newValue?:any) => any\n}\n\nexport class DateRangeAccessor extends FilterBasedAccessor<ObjectState> {\n  options:DateRangeAccessorOptions\n  state = new ObjectState({})\n  fieldContext:FieldContext\n  rangeFormatter:(count:number)=> number | string\n\n  constructor(key, options:DateRangeAccessorOptions){\n    super(key, options.id)\n    this.options = options\n    this.options.fieldOptions = this.options.fieldOptions || { type:\"embedded\" }\n    this.fieldContext = FieldContextFactory(this.options.fieldOptions)\n    this.rangeFormatter = this.options.rangeFormatter || identity\n\n    const { fromDate, toDate } = options\n    if (fromDate || toDate) {\n      this.state = this.state.setValue({\n        fromDate,\n        toDate\n      })\n    }\n  }\n\n  clearState = () => {\n    // Need to pass state reset through parent component so view can be updated\n    this.options.onClearState()\n  }\n\n  fromQueryObject(ob){\n    let fromValue = ob[this.urlKey + '_from']\n    let toValue = ob[this.urlKey + '_to']\n\n    if (fromValue || toValue) {\n      this.state = this.state.setValue({\n        fromDate: fromValue && moment(+fromValue),\n        toDate: toValue && moment(+toValue)\n      })\n    }\n  }\n\n  getQueryObject(){\n    let val:any = this.state.getValue()\n    let fromDate = val.fromDate && +val.fromDate\n    let toDate = val.toDate && +val.toDate\n    return (val) ? {\n      [this.urlKey + '_from']:fromDate,\n      [this.urlKey + '_to']:toDate\n    } : {}\n  }\n\n  buildSharedQuery(query) {\n    if (this.state.hasValue()) {\n      let val:any = this.state.getValue()\n      let fromDateRangeFilter = this.fieldContext.wrapFilter(DateRangeQuery(this.options.fromDateField,{\n        lte: +val.toDate\n      }))\n      let toDateRangeFilter = this.fieldContext.wrapFilter(DateRangeQuery(this.options.toDateField,{\n        gte: +val.fromDate\n      }))\n      const fromVal = this.rangeFormatter(val.fromDate);\n      const toVal = this.rangeFormatter(val.toDate);\n      const selectedFilterText = (val.toDate)\n        ? `${fromVal} – ${toVal}`\n        : `${fromVal} –`\n      let selectedFilter = {\n        name: this.translate(this.options.title),\n        value: selectedFilterText,\n        id: this.options.id,\n        remove: this.clearState\n      }\n\n      return query\n        .addFilter(this.key+'_to', fromDateRangeFilter)\n        .addFilter(this.key+'_from', toDateRangeFilter)\n        .addSelectedFilter(selectedFilter)\n    }\n\n    return query\n  }\n\n  getBuckets(){\n    return this.getAggregations([\n      this.key,\n      this.fieldContext.getAggregationPath(),\n      this.key, \"buckets\"], [])\n  }\n\n  isDisabled() {\n    // This accessor is never \"disabled\"; the calendar should always be visible\n    return false\n  }\n\n  buildOwnQuery(query) {\n    if (this.state.hasValue()) {\n      let val:any = this.state.getValue()\n      let otherFilters = query.getFiltersWithoutKeys(this.key)\n      let filters = BoolMust([\n        otherFilters,\n        this.fieldContext.wrapFilter(\n          DateRangeQuery(this.options.fromDateField, {\n            lte: +val.toDate\n          })\n        ),\n        this.fieldContext.wrapFilter(\n          DateRangeQuery(this.options.toDateField, {\n            gte: +val.fromDate\n          })\n        )\n      ])\n\n      query = query.setAggs(\n        FilterBucket(\n          this.key,\n          filters\n        )\n      )\n    }\n\n    return query\n  }\n}\n"]},"metadata":{},"sourceType":"module"}