{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar defaults = {\n  allowDots: false,\n  allowPrototypes: false,\n  arrayLimit: 20,\n  decoder: utils.decode,\n  delimiter: '&',\n  depth: 5,\n  parameterLimit: 1000,\n  plainObjects: false,\n  strictNullHandling: false\n};\n\nvar parseValues = function parseQueryStringValues(str, options) {\n  var obj = {};\n  var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n  for (var i = 0; i < parts.length; ++i) {\n    var part = parts[i];\n    var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n    var key, val;\n\n    if (pos === -1) {\n      key = options.decoder(part);\n      val = options.strictNullHandling ? null : '';\n    } else {\n      key = options.decoder(part.slice(0, pos));\n      val = options.decoder(part.slice(pos + 1));\n    }\n\n    if (has.call(obj, key)) {\n      obj[key] = [].concat(obj[key]).concat(val);\n    } else {\n      obj[key] = val;\n    }\n  }\n\n  return obj;\n};\n\nvar parseObject = function parseObjectRecursive(chain, val, options) {\n  if (!chain.length) {\n    return val;\n  }\n\n  var root = chain.shift();\n  var obj;\n\n  if (root === '[]') {\n    obj = [];\n    obj = obj.concat(parseObject(chain, val, options));\n  } else {\n    obj = options.plainObjects ? Object.create(null) : {};\n    var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n    var index = parseInt(cleanRoot, 10);\n\n    if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {\n      obj = [];\n      obj[index] = parseObject(chain, val, options);\n    } else {\n      obj[cleanRoot] = parseObject(chain, val, options);\n    }\n  }\n\n  return obj;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n  if (!givenKey) {\n    return;\n  } // Transform dot notation to bracket notation\n\n\n  var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks\n\n  var brackets = /(\\[[^[\\]]*])/;\n  var child = /(\\[[^[\\]]*])/g; // Get the parent\n\n  var segment = brackets.exec(key);\n  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists\n\n  var keys = [];\n\n  if (parent) {\n    // If we aren't using plain objects, optionally prefix keys\n    // that would overwrite object prototype properties\n    if (!options.plainObjects && has.call(Object.prototype, parent)) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(parent);\n  } // Loop through children appending to the array until we hit depth\n\n\n  var i = 0;\n\n  while ((segment = child.exec(key)) !== null && i < options.depth) {\n    i += 1;\n\n    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(segment[1]);\n  } // If there's a remainder, just add whatever is left\n\n\n  if (segment) {\n    keys.push('[' + key.slice(segment.index) + ']');\n  }\n\n  return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n  var options = opts || {};\n\n  if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n    throw new TypeError('Decoder has to be a function.');\n  }\n\n  options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n  options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n  options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n  options.parseArrays = options.parseArrays !== false;\n  options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n  options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n  options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n  options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n  options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n  options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n  if (str === '' || str === null || typeof str === 'undefined') {\n    return options.plainObjects ? Object.create(null) : {};\n  }\n\n  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object\n\n  var keys = Object.keys(tempObj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var newObj = parseKeys(key, tempObj[key], options);\n    obj = utils.merge(obj, newObj, options);\n  }\n\n  return utils.compact(obj);\n};","map":{"version":3,"sources":["/Users/salonibhogale/qhsearchui/node_modules/searchkit/node_modules/qs/lib/parse.js"],"names":["utils","require","has","Object","prototype","hasOwnProperty","defaults","allowDots","allowPrototypes","arrayLimit","decoder","decode","delimiter","depth","parameterLimit","plainObjects","strictNullHandling","parseValues","parseQueryStringValues","str","options","obj","parts","split","Infinity","undefined","i","length","part","pos","indexOf","key","val","slice","call","concat","parseObject","parseObjectRecursive","chain","root","shift","create","cleanRoot","charAt","index","parseInt","isNaN","String","parseArrays","parseKeys","parseQueryStringKeys","givenKey","replace","brackets","child","segment","exec","parent","keys","push","module","exports","opts","TypeError","isRegExp","tempObj","newObj","merge","compact"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    parameterLimit: 1000,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos));\n            val = options.decoder(part.slice(pos + 1));\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObjectRecursive(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n"]},"metadata":{},"sourceType":"script"}